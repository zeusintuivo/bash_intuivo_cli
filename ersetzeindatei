#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
#
THISSCRIPTNAME=`basename "$0"`
#bash shell script check input argument
FAIL=0;
echo "   ";
if [ -z "$1" ]
  then
    echo "Missing 1st argument "
    FAIL=1;
fi

if [ -z "$2" ]
  then
    echo "Missing 2nd argument "
    FAIL=1;
fi
if [ -z "$3" ]
  then
    echo "Missing 3rd argument "
  FAIL=1;
fi

if [ $FAIL -eq 1 ]
  then
  echo " "
  echo "Sample Usage:    - expects three arguments "
  echo " "
  echo "    ./${THISSCRIPTNAME}  TARGETFILE  seek_this      replaced_it_with        "
  echo "    ";
  exit 1;
fi

if [ -z "$4" ]
  then
    {
      echo "Missing 4th optional argument "
      echo " "
    echo "Can be used:    - with three arguments "
    echo " "
    echo "    ${THISSCRIPTNAME} TARGETFILE      seek_this       replaced_it_with          [ack, sift, grep, ag]"
    echo "    ";
    echo "    assuming order or use ag -> ack -> grep -> local ./ack"
    echo "    ";
    # Ack works to replace, but sift, grep, ag fail to replace with current setup
    # grep .* works for .zshrc
      DEFAULTSEEKER="ack"
    }
  else
    {
      DEFAULTSEEKER="$4"
    }

fi

red=`tput setaf 1`
cyan=`tput setaf 6`
green=`tput setaf 2`
reset=`tput sgr0`

BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
yellow=$(tput setaf 3)
LIME_YELLOW=$(tput setaf 190)
POWDER_BLUE=$(tput setaf 153)
BLUE=$(tput setaf 4)
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
BRIGHT=$(tput bold)
NORMAL=$(tput sgr0)
BLINK=$(tput blink)
REVERSE=$(tput smso)
UNDERLINE=$(tput smul)

FILE="$1";
SEEKER="./ack";
IGNORE_DIR="ignore";
FILESCOMMAND="";
PRINTCOMMAND="-l --print0";


# Test to see if file exists first
if [ ! -f "${FILE}" ] ; then
  {
    echo -e "${reset} File:\n      ${FILE} ${red} NOT Found! ${reset} ";
    exit 1;
  }
fi


msg_red () {
    printf "\n${bdr}%s ${off}%s\n" "${red} $@"
}

msg_green () {
    printf "\n${bdg}%s ${off}%s\n" "${green} $@"
}

trap '{ msg_red " KEYBOARD INTERRUPT."; exit 130; }' INT
#
# C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
#
test_positives(){
  KIND=""
  ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1;
  if (( $? == 0 )) ;  then  # Intel processor
    KIND="INTEL"
  fi
  if [ $? == 0 ]; then   # Mac Intel processor
    KIND="${KIND}MAC"
  fi
  echo "${KIND}"
}
PROCESSOR_ERROR=$(test_positives)
# DEBUG MACPOSITIVE MACPOSITIVE echo "${PROCESSOR_ERROR}"
# DEBUG MACPOSITIVE exit 1
#
# C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
#

#
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  --Start
#
check_replacer () {
  local REPLACER="$1"
  if command -v "${REPLACER}" >/dev/null 2>&1; then
    # It looks installed
    # .. is it working properly
    # msg_green " ${1} INSTALLED."

    #stdout UND stderr -capture  REF: https://www.thomas-krenn.com/de/wiki/Bash_stdout_und_stderr_umleiten
    ${REPLACER}  --version &> /tmp/ersetze_test_${REPLACER}.txt
    local PROPERLYWORKING=$(cat /tmp/ersetze_test_${REPLACER}.txt)

    if [[ "$PROPERLYWORKING" == *"dyld:"* ]]; then { echo "error"; return;} fi
    if [[ "$PROPERLYWORKING" == *"GNU"* ]]; then { echo "GNU"; return;} else { echo "MAC";return;} fi
    echo "checked";
    return;
  else
    # msg_red "${green} ${red} CANNOT REPLACE ...${1} IS MISSING ";
    # msg_red " NEED TO INSTALL ${1}.       Linux:    sudo apt-get install ${1}         Mac:     brew install ${1}   "
    echo "install";
    return;
  fi
}
msg_install () {
  msg_red "${green} ${red} CANNOT REPLACE ...${1} IS MISSING ";
  msg_red " NEED TO INSTALL ${1}.       Linux:    sudo apt-get install ${1}         Mac:     brew install ${1}   "
}
# REPLACER="sed";
# Try vim's ex ..broke here grrr TODO research how to implement doing erestese_indatei /images/projects/ images/projects index.html did not work at all
REPLACER="sed"; # changed to sed
VALIDREPLACER=$(check_replacer "${REPLACER}")

if [[ $VALIDREPLACER == "error" ]] ; then
  msg_red "Error with replacer ${REPLACER}"
  msg_red " - Error:"
  cat /tmp/ersetze_test_${REPLACER}.txt
   rm /tmp/ersetze_test_${REPLACER}.txt
fi

if [[ $VALIDREPLACER == "install" ]] ; then
  msg_install "${REPLACER}"
fi
rm /tmp/ersetze_test_${REPLACER}.txt

# TODO - Remove Repetition HERE
# ? empty still
if [[ $VALIDREPLACER == "install" || $VALIDREPLACER == "error"  ]] ; then
  REPLACER="sed";
  VALIDREPLACER=$(check_replacer "${REPLACER}")

  if [[ $VALIDREPLACER == "error" ]] ; then
    msg_red "Error with replacer ${REPLACER}"
    msg_red " - Error:"
    cat /tmp/ersetze_test_${REPLACER}.txt
     rm /tmp/ersetze_test_${REPLACER}.txt
    exit 1;
  fi

  if [[ $VALIDREPLACER == "install" ]] ; then
    msg_install "${REPLACER}"
    rm /tmp/ersetze_test_${REPLACER}.txt
    exit 1;
  fi
fi



REPLACERGNU="NO"
if [[ $VALIDREPLACER == "GNU" ]] ; then
  REPLACERGNU="YES"
fi

# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  -- RESULTS
# Results as
#             $REPLACERGNU  NO OR YES
#             $REPLACERGNU  ex or sed
#             halts execution if not found
#
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  -- End

#
# S E E K I N G   I N S T A L L    C H E C K  - Start
#
if command -v sift >/dev/null 2>&1; then
	{
	    msg_green " sift INSTALLED."
	    #-i, --ignore-case      case insensitive (default: off) Case sentive by default
	    #-n, --line-number      show line numbers (default: off)
	    #-Q, --literal          treat pattern as literal, quote meta characters
	    #--output-sep=          output separator (default: "\n")
      # Error: sift Error: files skipped due to very long lines
      # Fix:
      #   REF: https://github.com/svent/sift/issues/16
      #    As of version 0.4.0 sift supports two new options:
      #
      #    --err-skip-line-length to skip these errors
      #    --blocksize to specify a larger blocksize, allowing to search files with very long lines. Example: --blocksize 10M
	    SEEKER="sift -nQ  --blocksize 50M";
	    IGNORE_DIR="exclude-dirs";
	    IGNORE_FILE="exclude-files";
	    PRINTCOMMAND="-l --output-sep=\"\\x00\"";
	}
else
	{

	if command -v ag >/dev/null 2>&1; then
		{

	    msg_green " ag INSTALLED."
	    # -s  is for case sensitive
	    #-Q --literal            Don't parse PATTERN as a regular expression
	    #-0 --null --print0      Separate filenames with null (for 'xargs -0')
	    SEEKER="ag -sQ ";
	    IGNORE_DIR="ignore";
        IGNORE_FILE="ignore";
        PRINTCOMMAND="-l --print0";
		}
	else
		{

		#msg_red " NEED TO INSTALL ag."
	    #msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
		#sudo apt-get install silversearcher-ag -fy

		if command -v ack >/dev/null 2>&1; then
			{

		    msg_green " ack INSTALLED."
		    # ack is case sensitve by default
			# --print0 Print null byte as separator between filenames, only works with -f, -g, -l, -L or -c.
		    # -Q, --literal                 Quote all metacharacters; PATTERN is litera
	    	SEEKER="ack -Q ";
	    	IGNORE_DIR="ignore-dir";
            IGNORE_FILE="ignore-file";
            PRINTCOMMAND="-l --print0";

			}
		else
			{

			#msg_red " NEED TO INSTALL ack."
	    	#msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
			#sudo apt-get install ack-grep -fy

			ls ./ack  | egrep 'ack' &>/dev/null
			if [ $? == 0 ]; then
				{

			    msg_green " ./ack INSTALLED."
				SEEKER="./ack -Q ";
				IGNORE_DIR="ignore-dir";
            	IGNORE_FILE="ignore-file";
            	PRINTCOMMAND="-l --print0";
				}
			else
				{

				#msg_red " NEED TO INSTALL ./ack "
		    	#msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
				# cp ~/bin/ack .

				if command -v grep >/dev/null 2>&1; then
					{
					#-i, --ignore-case
					# Perform case insensitive matching.  By default, grep is case sensitive.
					#
					#-E, --extended-regexp
					# Interpret pattern as an extended regular expression (i.e. force grep to behave as
					# egrep).
					#
					#-e pattern, --regexp=pattern
					# Specify a pattern used during the search of the input: an input line is selected if it
					# matches any of the specified patterns.  This option is most useful when multiple -e
					# options are used to specify multiple patterns, or when a pattern begins with a dash
					# (`-').
					#-F, --fixed-strings
					# Interpret pattern as a set of fixed strings (i.e. force grep to behave as fgrep).


				    msg_green " grep INSTALLED."
				    SEEKER="grep -rnE ";
		            IGNORE_DIR="exclude-dir";
		            IGNORE_FILE="exclude";
		            FILESCOMMAND=".";
		            PRINTCOMMAND="-l --print0";
					}
				else
					{

					echo "${green} ${red} CANNOT SEARCH ....MISSING SEARCHER SIFT, ACK, AG, ./ACK, ./AG, ./SIFT OR GREP  ";
					exit 1;
			    	#msg_red " NEED TO INSTALL grep."
					}
				fi
				}
			fi
			}
		fi
		}
	fi
	}
fi
#CHECK FOR CHOICE FORCE IT
if command -v ${DEFAULTSEEKER} >/dev/null 2>&1; then
    {
        SEEKER="${DEFAULTSEEKER}";

        echo "${cyan}  using chosen option ... ${SEEKER}  "
        msg_green " ${SEEKER} INSTALLED."

        # make case sentive for local sift
        if [ $DEFAULTSEEKER == "sift" ]; then
        {
  		    SEEKER="sift -nQ --blocksize 50M";
  		    IGNORE_DIR="exclude-dirs";
  		    IGNORE_FILE="exclude-files"
  		    PRINTCOMMAND="-l --output-sep=\"\\x00\"";
		    }
        fi
        # make case sentive for ag
        if [ $DEFAULTSEEKER == "ag" ]; then
        {
            SEEKER="ag -sQ "
            IGNORE_DIR="ignore";
            IGNORE_FILE="ignore";
            PRINTCOMMAND="-l --print0";
        }
        fi
        # make case sentive for ag
        if [ $DEFAULTSEEKER == "ack" ]; then
        {
            SEEKER="ack -Q "
            IGNORE_DIR="ignore-dir";
            IGNORE_FILE="ignore-dir";
            PRINTCOMMAND="-l --print0";
        }
        fi
        # make case sentive for local ./ack
        if [ $DEFAULTSEEKER == "./ack" ]; then
        {
            SEEKER="./ack -Q "
            IGNORE_DIR="ignore-dir";
            IGNORE_FILE="ignore-file";
            PRINTCOMMAND="-l --print0";
        }
        fi
        #use extended expressions
        if [ $DEFAULTSEEKER == "grep" ]; then
        {
            SEEKER="grep -rnE "
            IGNORE_DIR="exclude-dir";
            IGNORE_FILE="exclude";
            FILESCOMMAND=".";
            PRINTCOMMAND="-l --print0";
        }
        fi
    }
else
    {
    #echo "${red}   your seeker ${DEFAULTSEEKER} was not found!"
    echo "${cyan}  using ...${SEEKER}  "
    }
fi

# TARGET COMPOSITION
# IGNORELIST="--${IGNORE_FILE}=composer.phar --${IGNORE_DIR}=vendor --${IGNORE_DIR}=.git --${IGNORE_DIR}=bower_components  --${IGNORE_DIR}=node_modules --${IGNORE_DIR}=storage/debugbar  --${IGNORE_DIR}=storage/logs  --${IGNORE_DIR}=app/Stubs "
#
# COMPOSE IGNORE ONELINER - start
#
EXCLUDEDIR="--${IGNORE_DIR}="
EXCLUDEFILE="--${IGNORE_FILE}="
FILESTOEXCLUDE="composer.phar"
DIRSTOEXCLUDE="vendor
.git
bower_components
node_modules
storage/debugbar
storage/logs
app/Stubs
var/cache
var/logs
var/session
tmp"

IGNORELIST=""

    while read -r ONE_FILENAME; do
      # if not empty
      if [ ! -z "${ONE_FILENAME}" ] ; then
        IGNORELIST="${IGNORELIST} ${EXCLUDEFILE}${ONE_FILENAME}"
      fi
    done <<< "${FILESTOEXCLUDE}"
    while read -r ONE_DIRNAME; do
      # if not empty
      if [ ! -z "${ONE_DIRNAME}" ] ; then
        IGNORELIST="${IGNORELIST} ${EXCLUDEDIR}${ONE_DIRNAME}"
      fi
    done <<< "${DIRSTOEXCLUDE}"
#
# COMPOSE IGNORE ONELINER - end
#

# S E E K I N G   I N S T A L L    C H E C K  - Results
# Results as
#             $SEEKER  seeker program selected form this priority sift, ag, ack, grep
#             $IGNORE_DIR  keyword used to ignore dir by program
#             $IGNORE_FILE  keyword used to ignore dir by program
#             $FILESCOMMAND  usually a dot (.) to indicate to search from (this) folder
#             $PRINTCOMMAND  the pipiing command to funel to results to replacer program
#             $IGNORELIST  construct of ignored files
#             halts execution if not found
#
SEEKING="$2";
echo "${reset} ${green} Finding ${reset} $SEEKING ${green}                 with  ${SEEKER} ."
echo "   ";

echo "   ";
echo "${reset} ${green} Seek ignoring $(echo ${IGNORELIST} | sed  "s@${EXCLUDEDIR}@@g" | sed  "s@${EXCLUDEFILE}@@g"  | sed  "s@ @,@g") with ${SEEKER} -- "
#
# S E E K I N G   I N S T A L L    C H E C K  - End
#


# echo "${cyan}  ack  --ignore=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" "
# echo "${cyan}  ag  --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" "
# echo "${cyan}  grep  --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs \"${SEEKING}\" "
echo "   ";
# THIS IS GREP FOR LINUX
# ack  --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING"
# ag  --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING"
# grep  --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs "$SEEKING"
#THIS IS GREP FOR MAC
# grep  --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs -e "$SEEKING" *

if [[ $SEEKING == *"/"* ]]
then
{


echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}   ${FILE}"
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   ${FILE}
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   ${FILE} | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
else
{

echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}   ${FILE}"
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   ${FILE}
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   ${FILE} | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
fi
################       ##############         ####          ####    ####        ####    ################
################       ##############         ####          ####    ####        ####    ################
####                 ####          ####       ####          ####    ######      ####    ####          ####
####                 ####          ####       ####          ####    ######      ####    ####          ####
####                 ####          ####       ####          ####    ##########  ####    ####          ####
####                 ####          ####       ####          ####    ##########  ####    ####          ####
############         ####          ####       ####          ####    ####  ####  ####    ####          ####
############         ####          ####       ####          ####    ####  ####  ####    ####          ####
####                 ####          ####       ####          ####    ####    ########    ####          ####
####                 ####          ####       ####          ####    ####    ########    ####          ####
####                 ####          ####       ####          ####    ####      ######    ####          ####
####                 ####          ####       ####          ####    ####      ######    ####          ####
####                   ##############           ##############      ####        ####    ################
####                   ##############           ##############      ####        ####    ################

err_buff=$?
# echo "err_buff=$err_buff"
# echo "PROCESSOR_ERROR=$PROCESSOR_ERROR"
if [[ "${PROCESSOR_ERROR}" == "INTEL" ]] && (( $err_buff == 0 )); then
{
    msg_green "${green} FOUND !"
    echo "    ";
    FOUND=1
}
elif [[ "${PROCESSOR_ERROR}" == "MAC" ]] && [ $err_buff == 0 ]; then
{
    msg_green "${green} FOUND !"
    echo "    ";
    FOUND=1
}
else
{
    msg_red "${red} SORRY NO FOUND OCCURENCES !"
    echo "    ";
    FOUND=0
    exit 1;
}
fi
# If  | egrep "$SEEKING" &>/dev/null | returned an error....so it was... it was found/not found say it and stop execution for not found
# if [ $? -eq 0 ]
# then
# 	{
# 	msg_green "${green} FOUND !"
# 	echo "    ";
# 	}
# else
# 	{
# 	msg_red "${red} SORRY NO OCCURENCES FOUND !"
# 	echo "    ";
# 	exit 0;
# 	}
# fi



echo "   ";
echo "${yellow} ...";




# R E P L A C E    P A R T


# echo $0=./replace
IMPLACING="$3";
NEW="$3";

# Keep this commands for reference DON'T DELETE  KEEP KEEP
# echo "${cyan}  ack -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" --print0 | xargs -0 sed  -i  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g"
# echo "${cyan}  ag -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" --print0 | xargs -0 sed  -i  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g"
# echo "${cyan}  grep -l --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs \"${SEEKING}\" --print0 | xargs -0 sed  -i  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g"
# ack -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING" --print0 | xargs -0 sed  -i  -e s/"$SEEKING"/"$IMPLACING"/g
# ag -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING" --print0 | xargs -0 sed  -i  -e s/"$SEEKING"/"$IMPLACING"/g
# grep -l --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs "$SEEKING" --print0 | xargs -0 sed  -i  -e s/"$SEEKING"/"$IMPLACING"/g
# Keep this commands for reference DON'T DELETE  KEEP KEEP


# echo "${reset} ${green} Replacing ${reset} $SEEKING ${green} for ${reset} $IMPLACING  ${green} with Sed."
echo "${reset} ${green} Replacing ${reset} $SEEKING ${green} for ${reset} $IMPLACING  ${green} with  ${SEEKER}."
if [[ $REPLACER == "sed" ]] ; then
	{
    # check operation systems
    (
      if [[ "$(uname)" == "Darwin" ]] ; then
        # Do something under Mac OS X platform
        echo " "
      elif [[ "$(expr substr $(uname -s) 1 5)" == "Linux" ]] ; then
        # Do something under GNU/Linux platform
        echo " "
      elif [[ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]] ; then
        # Do something under Windows NT platform
      	msg_red "${green} ${red} WARNING INSIDE WINDOWS Sed locks you out of your file, and the solution is that you have to recreate the file again."
        # nothing here
      fi
    )
	}
fi
echo "   ";



echo "${yellow} REPLACING NOW !        . . . using ${REPLACER} command ";

# REF # http://stackoverflow.com/questions/11245144/replace-whole-line-containing-a-string-using-sed
# The accepted answer did not work for me for several reasons:
#
#  • my version of sed does not like -i with a zero length extension
#  • the syntax of the c\ command is weird and I couldn't get it to work
#  • I didn't realize some of my issues are coming from unescaped slashes
#
# So here is the solution I came up with which I think should work for most cases:
#
APPLIED_ENTER=0
function enter_escape_for_sed {
  #sed ':a;N;$!ba;s/\n/0N33NT3R/g'  # GNU sed
  sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g'  #  cross-platform compatible syntax which works with BSD sed
  APPLIED_ENTER=$?
}
function enter_decode() {
  sed 's/\\n/\n/g'
}
function escape_slashes {
    sed 's/\//\\\//g'
}
function escape_quotes {
    sed 's/\"/\\\"/g'
}

function change_line {
    local OLD_LINE_PATTERN=$1; shift
    local NEW_LINE=$1; shift
    local FILE=$1

    local NEW=$(echo "${NEW_LINE}" | escape_slashes)
    sed -i .bak '/'"${OLD_LINE_PATTERN}"'/s/.*/'"${NEW}"'/' "${FILE}"
    mv "${FILE}.bak" /tmp/
}
# So the sample usage to fix the problem posed:
# change_line "TEXT_TO_BE_REPLACED" "This line is removed by the admin." yourFile

#OLD_LINE_PATTERN=$SEEKING;
#NEW_LINE=$2;
#FILE=$3
IMPLACING=$(echo "${NEW}"  | escape_slashes | escape_quotes)
TESTENTERIMPLACING=$(echo "${IMPLACING}" | enter_escape_for_sed)

if [[ "${IMPLACING}" == "${TESTENTERIMPLACING}" ]] ; then
{
  APPLIED_ENTER=0
}
else
{
  APPLIED_ENTER=1
  IMPLACING=$TESTENTERIMPLACING
}
fi

err_buff=0

#
# REPLACE - start
#
# If it contains forward slashes then use a different seeker
if [[ $SEEKING == *"/"* ]]; then
  # contains slashes
  {
    if [[ "${REPLACER}" == "sed" ]] ; then
      # sed
      {
        if [[ "${REPLACERGNU}" == "YES" ]] ; then
          # sed GNU
          {
         echo "${cyan}   sed  -i  -e s\"${SEEKING}\"\"${IMPLACING}\"g ${FILE}"
                         sed  -i  -e s"$SEEKING""$IMPLACING"g ${FILE} | ${SEEKER} "$SEEKING" ${FILESCOMMAND} &>/dev/null
                         err_buff=$?
          }
        else
          # sed mac
          # MAC REPLACER Has to HAVE A FILENAME.EXTENSION provided for the -i (inplace) option
          {
          # Sample use: ${THISSCRIPTNAME} /usr/bin/env\ bash  /bin/bash
          echo "${cyan}  sed  -i'.sedbak'  -e s\"${SEEKING}\"\"${IMPLACING}\"g ${FILE}"
                         sed  -i'.sedbak'  -e s"$SEEKING""$IMPLACING"g ${FILE} | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
                         err_buff=$?
          }
        fi
      }
    else
      # ex
      # REF: http://askubuntu.com/questions/20414/find-and-replace-text-within-a-file-using-commands
      {
        echo "${cyan}   ex -sc '%s$SEEKING$IMPLACINGg|x' ${FILE} "
                        ex -sc '%s$SEEKING$IMPLACINGg|x' ${FILE}
                        err_buff=$?
      }
    fi
  }
  else
  # contains not slashes in the expresion
  {
    if [[ "${REPLACER}" == "sed" ]] ; then
      # sed
      {
        if [[ "${REPLACERGNU}" == "YES" ]] ; then
          # sed GNU
          {
            echo "${cyan}   sed -i -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g ${FILE}"
                            sed -i -e s/"$SEEKING"/"$IMPLACING"/g ${FILE} | ${SEEKER} "$SEEKING" ${FILESCOMMAND} &>/dev/null
                            err_buff=$?
          }
        else
          # sed mac
          # MAC REPLACER Has to HAVE A FILENAME.EXTENSION provided for the -i (inplace) option
          {
            echo "${cyan}   sed  -i'.sedbak'  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g" ${FILE}
                            sed  -i'.sedbak'  -e s/"$SEEKING"/"$IMPLACING"/g ${FILE} | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
                            err_buff=$?
          }
        fi
      }
    else
      # ex
      {
        # VIM ex To find and replace all occurrences of case insensitive 'eth1' with 'br1', enter:
        echo "${cyan}   ex -sc '+%s/$SEEKING/$IMPLACING/g|x' ${FILE} "
                        ex -sc '+%s/$SEEKING/$IMPLACING/g|x' ${FILE}
                        err_buff=$?
      }
    fi
  }
fi
echo "    ";
#
# REPLACE - end
#
##########     ##########  ##########    ##              ####        ########    ##########  ##########
##########     ##########  ##########    ##              ####        ########    ##########  ##########
##        ##   ##          ##        ##  ##            ##    ##    ##        ##  ##          ##        ##
##        ##   ##          ##        ##  ##            ##    ##    ##        ##  ##          ##        ##
##        ##   ########    ##        ##  ##          ##        ##  ##            ########    ##        ##
##        ##   ########    ##        ##  ##          ##        ##  ##            ########    ##        ##
##########     ##          ##########    ##          ############  ##            ##          ##        ##
##########     ##          ##########    ##          ############  ##            ##          ##        ##
##      ##     ##          ##            ##          ##        ##  ##        ##  ##          ##        ##
##      ##     ##          ##            ##          ##        ##  ##        ##  ##          ##        ##
##        ##   ##########  ##            ##########  ##        ##    ########    ##########  ##########
##        ##   ##########  ##            ##########  ##        ##    ########    ##########  ##########
#
# If  | egrep "$SEEKING" &>/dev/null | returned an error....so it was... it was found/not found say it and stop execution for not found
#err_buff=$?
if [[ "${PROCESSOR_ERROR}" == "INTEL" ]] && (( $err_buff != 0 )); then
    {
    msg_green "${green} REPLACED !"
    echo "    ";
    FOUND=1
    }
elif [[ "${PROCESSOR_ERROR}" == "MAC" ]] && [ $err_buff != 0 ]; then
    {
    msg_green "${green} REPLACED !"
    echo "    ";
    FOUND=1
    }
else
    {
    msg_red "${red} SORRY NO REPLACEMENTS MADE !"
    echo "    ";
    exit 0;
    FOUND=0
    }
fi
# if [ $? == 0 ]; then
# 	{
# 	msg_green "${green} REPLACED !"
# 	echo "    ";
# 	}
# else
# 	{
# 	msg_red "${red} SORRY NO REPLACEMENTS MADE !"
# 	echo "    ";
# 	exit 0;
# 	}
# fi


echo "${green}  SEEKING ${yellow}  CONFIRM ${green} NEW VALUES NOW :   ";
echo "    ";
err_buff=0
SEEKING=$IMPLACING;
# echo "applied enter: ${APPLIED_ENTER}"
if [[ "${APPLIED_ENTER}" != 0 ]]; then
{
  SEEKING=$(echo $IMPLACING | enter_decode);
}
fi

if [[ $SEEKING == *"/"* ]]
then
{


echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}  ${FILE} "
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}  ${FILE}
                err_buff=$?
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}  ${FILE}  | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
else
{

echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}  ${FILE} "
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}  ${FILE}
                err_buff=$?
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}  ${FILE}  | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
fi
########       #####     ###        ###   ##########  ###   ########       ###        ###   #########  ########
#########      #####     ###        ###   ##########  ###   ########       ###        ###   #########  ########
##      ##   ##     ##   #####      ###   ###         ###   ###     ##     #####    #####   ##         ###     ##
##      ##   ##     ##   #####      ###   ###         ###   ###     ###    #####    #####   ##         ###     ##
##           ##     ##   ###  ##    ###   ########    ###   ###     ###    ###  ####  ###   #######    ###     ##
##           ##     ##   ###  ##    ###   ########    ###   ###     ##     ###  ####  ###   #######    ###     ##
##           ##     ##   ###    ##  ###   ###         ###   ########       ###        ###   ##         ###     ##
##           ##     ##   ###    ##  ###   ###         ###   ########       ###        ###   ##         ###     ##
##      ##   ##     ##   ###      #####   ###         ###   ###   ##       ###        ###   ##         ###     ##
##      ##   ##     ##   ###      #####   ###         ###   ###   ###      ###        ###   ##         ###     ##
#########     #######    ###        ###   ###         ###   ###     ###    ###        ###   #########  ########
########       #####     ###        ###   ###         ###   ###     ###    ###        ###   #########  ########
# INVERSE SWITCH If  | egrep "$SEEKING" &>/dev/null | returned an error....so it was... it was found/not found say it and stop execution for not found
# if [ $? == 0 ]; then
#   {
#   echo "    ";
#   echo "${cyan} REPLACE CONFIRMED ${green} FOUND !"
#   if [[ "${REPLACER}" == "sed" &&  "${REPLACERGNU}" == "NO" ]] ; then
#     remove .sedbak
#   fi
#   echo "    ";
#   }
# else
#   {
#   msg_red "${red} REPLACEMENT FAILED !"
#   echo "    ";
#   exit 0;
#   }
# fi
# echo "err_buff=$err_buff"
if [[ "${PROCESSOR_ERROR}" == "INTEL" ]] && (( $err_buff == 0 )); then
    {
    echo "    ";
    echo "${cyan} REPLACE CONFIRMED ${green} FOUND !"
    if [[ "${REPLACER}" == "sed" &&  "${REPLACERGNU}" == "NO" ]] ; then
        remove .sedbak
    fi
    echo "    ";
    }
elif [[ "${PROCESSOR_ERROR}" == "MAC" ]] && [ $err_buff == 0 ]; then
    {
    echo "    ";
    echo "${cyan} REPLACE CONFIRMED ${green} FOUND !"
    if [[ "${REPLACER}" == "sed" &&  "${REPLACERGNU}" == "NO" ]] ; then
        remove .sedbak
    fi
    echo "    ";
    }
else
    {
    msg_red "${red} REPLACEMENT FAILED !"
    echo "    ";
    exit 0;
    }
fi


echo "   ";
echo "${yellow} ...";
