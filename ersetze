#!/usr/bin/env bash
#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
# ls  | xargs -I {} sed -i -e 's@bash_crm_cli@bash_intuivo_cli@g' {}
# find * -type f  | xargs -I {} sed -i -e 's@bash_crm_cli@bash_intuivo_cli@g' {}
#
THISSCRIPTNAME=`basename "$0"`
# bash shell script check input argument


# Bash: Detect pipe/file input in a shell script
# REF: https://gist.github.com/davejamesmiller/1966557

# How to detect whether input is from keyboard, a file, or another process.
# Useful for writing a script that can read from standard input, or prompt the
# user for input if there is none.

# Source: http://www.linuxquestions.org/questions/linux-software-2/bash-scripting-pipe-input-to-script-vs.-1-570945/
PIPED="";
COLORED="";
COUNTER=0;
# ag -i filefoo /bar/
# ag [FILE-TYPE] [OPTIONS] PATTERN [PATH]
# ack [OPTION]... PATTERN [FILES OR DIRECTORIES]
# sift [OPTIONS] PATTERN [FILE|PATH|tcp://HOST:PORT]...
#  sift [OPTIONS] [-e PATTERN | -f FILE] [FILE|PATH|tcp://HOST:PORT]...
#  sift [OPTIONS] --targets [FILE|PATH]...
#      grep [-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ] [-A num] [-B num] [-C[num]] [-e pattern] [-f file]
#          [--binary-files=value] [--color[=when]] [--colour[=when]] [--context[=num]]
#          [--label] [--line-buffered] [--null] [pattern] [file ...]
# In Bash you can also use test -t to check for a terminal:

if [ -t 0 ]; then
    # Terminal input (keyboard) - interactive
    PIPED=""
else
    # File or pipe input - non-interactive
    PIPED="YES"
    # REF: http://stackoverflow.com/questions/2746553/bash-script-read-values-from-stdin-pipe
    # read PIPED #TOOD Works on mac osx, pending to test in linux and windows
    PIPED=''
    # REF: https://stackoverflow.com/questions/7314044/use-bash-to-read-line-by-line-and-keep-space
    # REF: http://www.unix.com/shell-programming-and-scripting/58611-resetting-ifs-variable.html
    OLDIFS=$IFS            # resetting IFS variable
    IFS=''                 # to read line by line and keep space
    IFS= read -r ONEPIPE   # to avoid interpretation of backslashes.
    PIPED="${ONEPIPE}"
    [[ -n "$PIPED" ]] && COUNTER=$((COUNTER+1))

    while read ONEPIPE
    do

         PIPED="${PIPED}
${ONEPIPE}"
         COUNTER=$((COUNTER+1))
    done
        if [ $COUNTER -eq 0 ]; then
          IFS=$OLDIFS
          exit
        fi

    # action="${ONEPIPE/ /โ}"  # replace value inside string substitution expresion bash
    # TEST: echo "COUNTER: ${COUNTER}";echo "PIDED: ${PIPED}"; exit 0;
    IFS=$OLDIFS
fi

# Piped Input
# if [[ -n "$PIPED" ]]
# then
# echo "this is pipe..die "
# exit 0;
#fi
# NOT Piped Input
#if [ -z "$PIPED" ]
# then
# echo "this NOT pipe..die "
# exit 0;
#fi
#echo "PIPED:$PIPED";
#exit;

# ALTERNATIVE:
#if readlink /proc/$$/fd/0 | grep -q "^pipe:"; then
    # Pipe input (echo abc | myscript)
#    PIPED="YES"
#elif file $( readlink /proc/$$/fd/0 ) | grep -q "character special"; then
    # Terminal input (keyboard)
#    PIPED=""
#else
    # File input (myscript < file.txt)
#    PIPED=""

#fi


# CURRENT SCRIPT EXECUTING
THISSCRIPTNAME=`basename "$0"`
# bash shell script check input argument
FAIL=0;
echo "   ";
if [ -z "$1" ] && [ -z "$PIPED" ] ; then
{
    echo "Missing 1st argument "
    FAIL=1;
}
fi
VERBOSE=0;
DEFAULTSEEKER="pt"
FILENAMESONLY=0
SEEKING="$1";

if [ -z "$2" ]
  then
    echo "Missing 2nd argument "
    FAIL=1;
fi

if [ $FAIL -eq 1 ]
    then
    echo " "
    echo "Sample Usage:    - expects two arguments "
    echo " "
    echo "    ${THISSCRIPTNAME}    seek_this     replaced_it_with"
    echo "    ";
      exit
fi


if [[ "$1" == "-h" ]] && [[ -z "$PIPED" ]] ; then
{

  echo "${THISSCRIPTNAME} - Means replace in German"
  echo " "
  echo "Can be used:    - with three arguments "
  echo " "
  echo "    ${THISSCRIPTNAME} seek_this replaced_it_with   [ack, sift, grep, ag]"
  echo "    ";
  echo "    assuming order or use ag -> ack -> grep -> local ./ack"
  echo "    ";
  exit 0;
}
fi
VERBOSE=0;
DEFAULTSEEKER="pt"
if [ ! -z "$3" ] ; then # Third argument not zempty
  # Second Argument provided is -v and is not PIPED or PIDEd is empty
  if [[ "$3" == "-v" ]] && [ -z "$PIPED" ] ; then
  {
    echo "Verbose on";
    VERBOSE=1;
  }
  fi
  if [[ "$3" == "sift" || "$3" == "pt" || "$3" == "ack" || "$3" == "grep" || "$3" == "ag" || "$3" == "./ag" || "$3" == "./ack" || "$3" == "./sift" ]] ; then
  {
    DEFAULTSEEKER="$3"
  }
  fi
  if [[ "$3" == "--nocolor"  ]] ; then
  {
    COLORED="";
  }
  fi
  if [[ "$3" == "-f" ]] && [ -z "$PIPED" ] ; then
  {
      if [ $VERBOSE -eq 1 ] ; then
      {
        echo "Files on";
      }
      fi
      FILENAMESONLY=1;
  }
  fi
fi
if [ ! -z "$4" ] ; then # Third argument not zempty
  # Second Argument provided is -v and is not PIPED or PIDEd is empty
  if [[ "$4" == "-v" ]] && [ -z "$PIPED" ] ; then
  {
    echo "Verbose on";
    VERBOSE=1;
  }
  fi
  if [[ "$4" == "sift" || "$4" == "pt" || "$4" == "ack" || "$4" == "grep" || "$4" == "ag" || "$4" == "./ag" || "$4" == "./ack" || "$4" == "./sift" ]] ; then
  {
    DEFAULTSEEKER="$4"
  }
  fi
  if [[ "$4" == "--nocolor"  ]] ; then
  {
    COLORED=""; # "" is no "YES" is yes
  }
  fi
  if [[ "$4" == "-f" ]] && [ -z "$PIPED" ] ; then
  {
      if [ $VERBOSE -eq 1 ] ; then
      {
        echo "Files on";
      }
      fi
      FILENAMESONLY=1;
  }
  fi
fi
# TEST COLORED AND PIPED
# echo "$SEEKING"
#              #  NOT Colored
#             if [[ -n "$COLORED" ]] ; then
#             {
#               echo "NOT COLORED"
#             }
#             else
#             {
#               echo "[38;5;28mCOL[38;5;9mORED[0m"
#             }
#             fi
#               #  NOT Piped
#               if [ -z "$PIPED" ] ; then
#               {
#                 echo "NOT PIPED"
#               }
#               else
#               {
#                 echo "[38;5;28mPI[38;5;9mPED[0m"
#                 if [[ "$SEEKING" == *""* ]] ; then
#                 {
#                   echo "$SEEKING"
#                   echo "BUT PASSED CHARS HAVE COLOR"
#                 }
#                 else
#                 {
#                   echo "$SEEKING"
#                   echo "NO COLOR FROM BEHIND"
#                 }
#                 fi
#               }
#               fi
#               exit

              # Override colored off when piped with not color
              #  Piped
              if [ -n "$PIPED" ] ; then
                {

                  WHAT=$(echo "$PIPED" | grep -E "\[")
                  #echo "$WHAT";
                  if [ -z "$WHAT" ] ; then
                    {
                      #  Colored
                      COLORED="YES";  # "" is no "YES" is yes
                      #echo "z"
                    }
                  else
                    {
                      # NOT Colored
                      COLORED="";   # "" is no "YES" is yes
                      #echo "!z"
                    }
                  fi
                  #}
                  #| sed 's@\@ESC@'
                  #exit
                }
              fi
               #  NOT Colored
#             if [ -n "$COLORED" ] ; then
#                {
#                  echo "NOT COLORED"
#                }
#              else
#                {
#                  echo "[38;5;28mCOL[38;5;9mORED[0m"
#                }
#              fi
# #             exit

 ####        ####       #            ####       #####        ####
 ####        ####       #            ####       #####        ####
#    #      #    #      #           #    #      #    #      #
#    #      #    #      #           #    #      #    #      #
#           #    #      #           #    #      #    #       ####
#           #    #      #           #    #      #    #       ####
#           #    #      #           #    #      #####            #
#           #    #      #           #    #      #####            #
#    #      #    #      #           #    #      #   #       #    #
#    #      #    #      #           #    #      #   #       #    #
 ####        ####       ######       ####       #    #       ####
 ####        ####       ######       ####       #    #       ####

#
# COLORS - Ouput - Start
#

[[ -z "${RED}" ]] && RED="\\033[38;5;1m"
red=`tput setaf 1`
[[ -z "${CYAN}" ]] && CYAN="\\033[38;5;123m"
cyan=`tput setaf 6`
[[ -z "${GREEN}" ]] && GREEN="\\033[38;5;22m"
green=`tput setaf 2`
[[ -z "${RESET}" ]] && RESET="\\033[0m"
[[ -z "${RESET_PROMPT}" ]] && RESET_PROMPT="[0m"
reset=`tput sgr0`
[[ -z "${BLACK}" ]] && BLACK="\\033[38;5;16m"
black=$(tput setaf 0)
[[ -z "${YELLOW226}" ]] && YELLOW226="\\033[38;5;226m"
[[ -z "${YELLOW}" ]] && YELLOW="\\033[01;33m"
yellow=$(tput setaf 3)
LIME_YELLOW=$(tput setaf 190)
POWDER_BLUE=$(tput setaf 153)
BLUE=$(tput setaf 4)
[[ -z "${PURPLE}" ]] && PURPLE="\\033[01;35m"
MAGENTA=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)
BRIGHT=$(tput bold)
NORMAL=$(tput sgr0)
BLINK=$(tput blink)
REVERSE=$(tput smso)
UNDERLINE=$(tput smul)

#
# COLORS - Output - end
#


SEEKER="pt";
IGNORE_DIR="ignore";
FILESCOMMAND="";
PRINTCOMMAND="-l -0";
FOUND=0

msg_red () {
    printf "\n${bdr}%s ${off}%s\n" "${red} $@"
}

msg_green () {
    printf "\n${bdg}%s ${off}%s\n" "${green} $@"
}
msg_echo () {
    echo -e "${*}"
}
trap '{ msg_red " KEYBOARD INTERRUPT."; exit 130; }' INT

#
# C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
#
test_positives(){
  KIND=""
  if ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1; then
    if (( $? == 0 )) ;  then  # Intel processor
      KIND="INTEL"
    fi
    if [ $? == 0 ]; then   # Mac Intel processor
      KIND="${KIND}MAC"
    fi
  else
    if (( $? == 0 )) ;  then  # Intel processor
      KIND="INTEL"
    fi
    if [ $? == 0 ]; then   # Mac Intel processor
      KIND="${KIND}MAC"
    fi
  fi
  echo "${KIND}"
}
PROCESSOR_ERROR=$(test_positives)
# DEBUG MACPOSITIVE MACPOSITIVE echo "${PROCESSOR_ERROR}"
# DEBUG MACPOSITIVE exit 1
#
# C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
#

#
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  --Start
#
check_replacer () {
  local -i  _err
  local REPLACER="$1"
  if command -v "${REPLACER}" >/dev/null 2>&1; then
    # It looks installed
    # .. is it working properly
    # msg_green " ${1} INSTALLED."

    #stdout UND stderr -capture  REF: https://www.thomas-krenn.com/de/wiki/Bash_stdout_und_stderr_umleiten
    ${REPLACER}  --version &> /tmp/ersetze_test_${REPLACER}.txt
    _err=$?
    local PROPERLYWORKING=$(cat /tmp/ersetze_test_${REPLACER}.txt)

    if [[ "$PROPERLYWORKING" == *"dyld:"* ]]; then { echo "error"; return;} fi
    if [[ "$PROPERLYWORKING" == *"GNU"* ]]; then { echo "GNU"; return;} else { echo "MAC";return;} fi
    if  [ ${_err} -ne 0 ] ; then { echo "error"; return;} fi
    echo "checked";
    return;
  else
    # msg_red "${green} ${red} CANNOT REPLACE ...${1} IS MISSING ";
    # msg_red " NEED TO INSTALL ${1}.       Linux:    sudo apt-get install ${1}         Mac:     brew install ${1}   "
    echo "install";
    return;
  fi
}
msg_install () {
  msg_red "${green} ${red} CANNOT REPLACE ...${1} IS MISSING ";
  msg_red " NEED TO INSTALL ${1}.       Linux:    sudo apt-get install ${1}         Mac:     brew install ${1}   "
}
# REPLACER="sed";
# Try vim's ex ..broke here grrr TODO research how to implement doing erestese_indatei /images/projects/ images/projects index.html did not work at all
REPLACER="sed"; # changed to sed
VALIDREPLACER=$(check_replacer "${REPLACER}")


if [[ $VALIDREPLACER == "error" ]] ; then
  msg_red "Error with replacer ${REPLACER}"
  msg_red " - Error:"
  cat /tmp/ersetze_test_${REPLACER}.txt
   rm /tmp/ersetze_test_${REPLACER}.txt
fi

if [[ $VALIDREPLACER == "install" ]] ; then
  msg_install "${REPLACER}"
fi
rm /tmp/ersetze_test_${REPLACER}.txt

# TODO - Remove Repetition HERE
# ? empty still
if [[ $VALIDREPLACER == "install" || $VALIDREPLACER == "error"  ]] ; then
  REPLACER="sed";
  VALIDREPLACER=$(check_replacer "${REPLACER}")

  if [[ $VALIDREPLACER == "error" ]] ; then
    msg_red "Error with replacer ${REPLACER}"
    msg_red " - Error:"
    cat /tmp/ersetze_test_${REPLACER}.txt
     rm /tmp/ersetze_test_${REPLACER}.txt
    exit 1;
  fi

  if [[ $VALIDREPLACER == "install" ]] ; then
    msg_install "${REPLACER}"
    rm /tmp/ersetze_test_${REPLACER}.txt
    exit 1;
  fi
fi



REPLACERGNU="NO"
if [[ $VALIDREPLACER == "GNU" ]] ; then
{
  REPLACERGNU="YES"
}
fi


# one more check for gsed from brew in macs
if [[ $REPLACERGNU == "NO" ]] ; then
{  
  if command -v gsed >/dev/null 2>&1 ; then 
  { 
    REPLACERGNU="YES"
    REPLACER="gsed"
  }
  fi
}
fi

XARGSCOMMAD=""
# Test
# echo "REPLACERGNU: $REPLACERGNU"
# echo "VALIDREPLACER: $VALIDREPLACER"
# exit
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  -- RESULTS
# Results as
#             $REPLACERGNU  NO OR YES
#             $REPLACERGNU  ex or sed
#             halts execution if not found
#
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  -- End

#
# S E E K I N G   I N S T A L L    C H E C K  - Start
#
if command -v pt >/dev/null 2>&1; then
{
  # pt --help
  # Usage:
  #  pt [OPTIONS] PATTERN [PATH]
  #
  # Application Options:
  #      --version             Show version
  #
  # Output Options:
  #      --color               Print color codes in results (default: true)
  #      --nocolor             Don't print color codes in results (default: false)
  #      --color-line-number=  Color codes for line numbers (default: 1;33)
  #      --color-path=         Color codes for path names (default: 1;32)
  #      --color-match=        Color codes for result matches (default: 30;43)
  #      --group               Print file name at header (default: true)
  #      --nogroup             Don't print file name at header (default: false)
  #  -0, --null                Separate filenames with null (for 'xargs -0') (default: false)
  #      --column              Print column (default: false)
  #      --numbers             Print Line number. (default: true)
  #  -N, --nonumbers           Omit Line number. (default: false)
  #  -A, --after=              Print lines after match
  #  -B, --before=             Print lines before match
  #  -C, --context=            Print lines before and after match
  #  -l, --files-with-matches  Only print filenames that contain matches
  #  -c, --count               Only print the number of matching lines for each input file.
  #  -o, --output-encode=      Specify output encoding (none, jis, sjis, euc)
  #
  # Search Options:
  #  -e                        Parse PATTERN as a regular expression (default: false). Accepted syntax is the same
  #                            as https://github.com/google/re2/wiki/Syntax except from \C
  #  -i, --ignore-case         Match case insensitively
  #  -S, --smart-case          Match case insensitively unless PATTERN contains uppercase characters
  #  -w, --word-regexp         Only match whole words
  #      --ignore=             Ignore files/directories matching pattern
  #      --vcs-ignore=         VCS ignore files (default: .gitignore)
  #      --global-gitignore    Use git's global gitignore file for ignore patterns
  #      --home-ptignore       Use $Home/.ptignore file for ignore patterns
  #  -U, --skip-vcs-ignores    Don't use VCS ignore file for ignore patterns
  #  -g=                       Print filenames matching PATTERN
  #  -G, --file-search-regexp= PATTERN Limit search to filenames matching PATTERN
  #      --depth=              Search up to NUM directories deep (default: 25)
  #  -f, --follow              Follow symlinks
  #      --hidden              Search hidden files and directories
  #
  # Help Options:
  #  -h, --help                Show this help message

  if [ $VERBOSE -eq 1 ] ; then
  {
    #  NOT Colored
    if [[ -n "$COLORED" ]] ; then
    {
      echo " pt INSTALLED."
    }
    else
    {
      msg_echo " pt INSTALLED."
    }
    fi
  }
  fi
  # pt is            case sensitive by default
  # -0, --null                Separate filenames with null (for 'xargs -0') (default: false)
  #     --nocolor             Don't print color codes in results (default: false)
  #
  # WHEN not PIPED then show line numbers
  # -N, --nonumbers           Omit Line number. (default: false)
          if [ -z "$PIPED" ] ; then
          {
              SEEKER=" pt --hidden  --numbers  "
          }
          fi
          #  PIPED then hide line numbers
          if [[ -n "$PIPED" ]] ; then
          {
              SEEKER=" pt --hidden  --nonumbers "
          }
          fi
  # NOT Colored
  if [[ -n "$COLORED" ]] ; then
  {
    SEEKER="${SEEKER} --nocolor ";
  }
  fi
  #  -l, --files-with-matches  Only print filenames that contain matches
  IGNORE_DIR="ignore";
  IGNORE_FILE="ignore";
  PRINTCOMMAND="-l --null";
  XARGSCOMMAD="-0"; 
}
else # // sift not installed
{
  if command -v sift >/dev/null 2>&1; then
  {
    if [ $VERBOSE -eq 1 ] ; then
    {
      #  NOT Colored
      if [[ -n "$COLORED" ]] ; then
      {
        echo " sift INSTALLED."
      }
      else
      {
        msg_echo " sift INSTALLED."
      }
      fi
    }
    fi
    # -i, --ignore-case      case insensitive (default: off) Case sentive by default
    # -n, --line-number      show line numbers (default: off)
    # -Q, --literal          treat pattern as literal, quote meta characters
    # --output-sep=          output separator (default: "\n")
    # --no-color             disable colored output
    # Error: sift Error: files skipped due to very long lines
    # Fix:
    #   REF: https://github.com/svent/sift/issues/16
    #    As of version 0.4.0 sift supports two new options:
    #
    #    --err-skip-line-length to skip these errors
    #    --blocksize to specify a larger blocksize, allowing to search files with very long lines. Example: --blocksize 10M
    SEEKER="sift -nQ  --blocksize 50M";

    # NOT PIPED then show line numbers
    if [ -z "$PIPED" ] ; then
    {
      SEEKER="sift --err-skip-line-length -nQ ";
    }
    fi
    #  PIPED then hide line numbers
    if [[ -n "$PIPED" ]] ; then
    {
      SEEKER="sift --err-skip-line-length -Q ";
    }
    fi
    #  NOT Colored
    if [[ -n "$COLORED" ]] ; then
    {
      SEEKER="${SEEKER} --no-color ";
    }
    fi
    IGNORE_DIR="exclude-dirs";
    IGNORE_FILE="exclude-files";
    PRINTCOMMAND="-l --output-sep=\"\\x00\"";
  }
  else # // pt not installed
  {

      # msg_red " NEED TO INSTALL pt."
      # msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
      # REF: https://github.com/monochromegane/the_platinum_searcher
      # sudo brew install the_platinum_searcher

    if command -v ag >/dev/null 2>&1; then
    {

      if [ $VERBOSE -eq 1 ] ; then
      {
        #  NOT Colored
        if [[ -n "$COLORED" ]] ; then
        {
          echo " ag INSTALLED."
        }
        else
        {
          msg_echo " ag INSTALLED."
        }
        fi
      }
      fi
      # -s  is for case sensitive
      #-Q --literal            Don't parse PATTERN as a regular expression
      #-0 --null --print0      Separate filenames with null (for 'xargs -0')
      #--nocolor               Disable colors (Enabled by default)
       # NOT PIPED then show line numbers
      if [[ -z "$PIPED" ]] ; then
      {
          SEEKER="ag -sQ ";
      }
      fi
      #  PIPED then hide line numbers
      if [[ -n "$PIPED" ]] ; then
      {
        SEEKER="ag --no-numbers -sQ  ";
      }
      fi
      #  NOT Colored
      if [[ -n "$COLORED" ]] ; then
      {
        SEEKER="${SEEKER} --nocolor ";
      }
      fi
      IGNORE_DIR="ignore";
      IGNORE_FILE="ignore";
      PRINTCOMMAND="-l --print0";
    }
    else # // ag not installed
    {

      # msg_red " NEED TO INSTALL ag."
      # msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
      # sudo apt-get install silversearcher-ag -fy

      if command -v ack >/dev/null 2>&1; then
      {
        if [ $VERBOSE -eq 1 ] ; then
        {
          #  NOT Colored
          if [[ -n "$COLORED" ]] ; then
          {
            echo " ack INSTALLED."
          }
          else
          {
            msg_echo " ack INSTALLED."
          }
          fi
        }
        fi
        # ack is            case sensitve by default
        # --print0          Print null byte as separator between filenames, only works with -f, -g, -l, -L or -c.
        # -Q, --literal     Quote all metacharacters; PATTERN is litera
        # --nocolor         Highlight the matching text (default: on unless --nocolor)
        #
        # Ack DOES NOT SUPPORT HIDING LINE NUMBERS
        # NOT PIPED then show line numbers

        if [[ -z "$PIPED" ]] ; then
        {
          SEEKER="ack -Q ";
        }
        fi
        #  PIPED then hide line numbers
        if [[ -n "$PIPED" ]] ; then
        {
          SEEKER="ack -Q ";
        }
        fi
        # NOT Colored
        if [[ -n "$COLORED" ]] ; then
        {
          SEEKER="${SEEKER} --nocolor ";
        }
        fi
        IGNORE_DIR="ignore-dir";
        IGNORE_FILE="ignore-file";
        PRINTCOMMAND="-l --print0";
      }
      else # // ack not installed
      {

        # msg_red " NEED TO INSTALL ack."
        # msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
        # sudo apt-get install ack-grep -fy

        ls ./ack  | egrep 'ack' &>/dev/null
        err_buff=$?
        if [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff == 0 ]; then
        {
            if [ $VERBOSE -eq 1 ] ; then
            {
               #  NOT Colored
              if [[ -n "$COLORED" ]] ; then
              {
                echo " ./ack INSTALLED."
              }
              else
              {
                msg_echo " ./ack INSTALLED."
              }
              fi
            }
            fi
            # Ack DOES NOT SUPPORT HIDING LINE NUMBERS
            # NOT PIPED then show line numbers
            if [ -z "$PIPED" ] ; then
            {
                SEEKER="./ack -Q ";
            }
            fi
            #  PIPED then hide line numbers
            if [[ -n "$PIPED" ]] ; then
            {
                SEEKER="./ack -Q ";
            }
            fi
            # NOT Colored
            if [[ -n "$COLORED" ]] ; then
            {
                SEEKER="${SEEKER} --nocolor ";
            }
            fi
            IGNORE_DIR="ignore-dir";
            IGNORE_FILE="ignore-file";
            PRINTCOMMAND="-l --print0";
        }
        elif [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff == 0 )); then
        {
          if [ $VERBOSE -eq 1 ] ; then
          {
             #  NOT Colored
            if [[ -n "$COLORED" ]] ; then
            {
              echo " ./ack INSTALLED."
            }
            else
            {
              msg_echo " ./ack INSTALLED."
            }
            fi
          }
          fi
          # Ack DOES NOT SUPPORT HIDING LINE NUMBERS
          # NOT PIPED then show line numbers
          if [ -z "$PIPED" ] ; then
          {
              SEEKER="./ack -Q ";
          }
          fi
          #  PIPED then hide line numbers
          if [[ -n "$PIPED" ]] ; then
          {
              SEEKER="./ack -Q ";
          }
          fi
          # NOT Colored
          if [[ -n "$COLORED" ]] ; then
          {
              SEEKER="${SEEKER} --nocolor ";
          }
          fi
          IGNORE_DIR="ignore-dir";
          IGNORE_FILE="ignore-file";
          PRINTCOMMAND="-l --print0";
        }
        else # // ./ack not installed
        {

          # msg_red " NEED TO INSTALL ./ack "
          # msg_red " ENTER SUDO PASSWORD AND PRESS ENTER."
          # cp ~/bin/ack .

          if command -v grep >/dev/null 2>&1; then
          {
            #-i, --ignore-case
            # Perform case insensitive matching.  By default, grep is case sensitive.
            #
            #-E, --extended-regexp
            # Interpret pattern as an extended regular expression (i.e. force grep to behave as
            # egrep).
            #
            #-e pattern, --regexp=pattern
            # Specify a pattern used during the search of the input: an input line is selected if it
            # matches any of the specified patterns.  This option is most useful when multiple -e
            # options are used to specify multiple patterns, or when a pattern begins with a dash
            # (`-').
            #-F, --fixed-strings
            # Interpret pattern as a set of fixed strings (i.e. force grep to behave as fgrep).
            # --color=never     disable color

            #
            # grep (GNU grep) 2.25
            # -l, --files-with-matches
            #    Suppress normal output; instead print the name  of  each  input
            #    file  from  which output would normally have been printed.  The
            #    scanning will stop on the first match.
            #
            # -Z, --null
            #    Output a zero byte (the ASCII NUL  character)  instead  of  the
            #    character that normally follows a file name.  For example, grep
            #    -lZ outputs a zero byte after each file  name  instead  of  the
            #    usual  newline.  This option makes the output unambiguous, even
            #    in the presence of file  names  containing  unusual  characters
            #    like newlines.  This option can be used with commands like find
            #    -print0, perl -0, sort -z, and xargs -0  to  process  arbitrary
            #    file names, even those that contain newline characters.
            #

            if [ $VERBOSE -eq 1 ] ; then
            {
              #  NOT Colored
              if [[ -n "$COLORED" ]] ; then
              {
                echo " grep INSTALLED."
              }
              else
              {
                msg_echo " grep INSTALLED."
              }
              fi
            }
            fi
            # WHEN PIPED then show line numbers
            if [ -z "$PIPED" ] ; then
            {
                SEEKER="grep -nrE "
            }
            fi
            #  PIPED then hide line numbers
            if [[ -n "$PIPED" ]] ; then
            {
                SEEKER="grep -rE "
            }
            fi
            # NOT Colored
            if [[ -n "$COLORED" ]] ; then
            {
              SEEKER="${SEEKER} --color=never ";
            }
            fi
            IGNORE_DIR="exclude-dir";
            IGNORE_FILE="exclude";
            FILESCOMMAND=".";
            # PRINTCOMMAND="-l --print0";
            PRINTCOMMAND="-l --null";
          }
          else # // grep not installed
          {
              # NOT Colored
              if [[ -n "$COLORED" ]] ; then
              {
                  echo "CANNOT SEARCH ....MISSING SEARCHER SIFT, ACK, AG, ./ACK, ./AG, ./SIFT OR GREP  ";
                  exit 1;
              }
              else
              {
                  echo -e "${RED} CANNOT SEARCH ....MISSING SEARCHER SIFT, ACK, AG, ./ACK, ./AG, ./SIFT OR GREP  ";
                  exit 1;
              }
              fi
              #msg_red " NEED TO INSTALL grep."
          }
          fi
        }
        fi
      }
      fi
    }
    fi
  }
  fi
}
fi
# show hidden chars
# echo -e "${CYAN}" | tr -dc '[:print:]' | od -c ;
# echo -e "${RED}" | tr -dc '[:print:]' ;
# exit 1;

#CHECK FOR CHOICE FORCE IT
if command -v "${DEFAULTSEEKER}" >/dev/null 2>&1; then
{
  SEEKER="${DEFAULTSEEKER}";
  echo "${cyan}  using chosen option ... ${SEEKER}  "
  msg_green " ${SEEKER} INSTALLED."

  # make case sentive for local sift
  if [ $DEFAULTSEEKER == "sift" ]; then
  {
    SEEKER="sift -nQ --blocksize 50M";
    IGNORE_DIR="exclude-dirs";
    IGNORE_FILE="exclude-files"
    PRINTCOMMAND="-l --output-sep=\"\\x00\"";
  }
  fi
  # make case sentive for ag
  if [[ "$DEFAULTSEEKER" == "ag" ]] ; then
  {
    SEEKER="ag -sQ "
    IGNORE_DIR="ignore";
    IGNORE_FILE="ignore";
    PRINTCOMMAND="-l --print0";
  }
  fi
  # make case sentive for ag
  if [[ "$DEFAULTSEEKER" == "ack" ]] ; then
  {
    SEEKER="ack -Q "
    IGNORE_DIR="ignore-dir";
    IGNORE_FILE="ignore-dir";
    PRINTCOMMAND="-l --print0";
  }
  fi
  # make case sentive for local ./ack
  if [ -e "./ack" ] && [[ "$DEFAULTSEEKER" == "./ack" ]] ; then
  {
    SEEKER="./ack -Q "
    IGNORE_DIR="ignore-dir";
    IGNORE_FILE="ignore-file";
    PRINTCOMMAND="-l --print0";
  }
  fi
  # use extended expressions
  if [[ "$DEFAULTSEEKER" == "grep" ]] ; then
  {
    SEEKER="grep -rnE "
    IGNORE_DIR="exclude-dir";
    IGNORE_FILE="exclude";
    FILESCOMMAND=".";
    # PRINTCOMMAND="-l --print0";
    PRINTCOMMAND="-l --null";
  }
  fi
}
else
{
  # echo "${red}   your seeker ${DEFAULTSEEKER} was not found!"
  echo "${cyan}  using ...${SEEKER}  "
}
fi



######      #    #       ####       #           #    #       ####       #       ####       #    #       ####
######      #    #       ####       #           #    #       ####       #       ####       #    #       ####
#            #  #       #    #      #           #    #      #           #      #    #      ##   #      #
#            #  #       #    #      #           #    #      #           #      #    #      ##   #      #
#####         ##        #           #           #    #       ####       #      #    #      # #  #       ####
#####         ##        #           #           #    #       ####       #      #    #      # #  #       ####
#             ##        #           #           #    #           #      #      #    #      #  # #           #
#             ##        #           #           #    #           #      #      #    #      #  # #           #
#            #  #       #    #      #           #    #      #    #      #      #    #      #   ##      #    #
#            #  #       #    #      #           #    #      #    #      #      #    #      #   ##      #    #
######      #    #       ####       ######       ####        ####       #       ####       #    #       ####
######      #    #       ####       ######       ####        ####       #       ####       #    #       ####


#
# TARGET COMPOSITION
# IGNORELIST="--${IGNORE_FILE}=composer.phar --${IGNORE_FILE}=phpunit  --${IGNORE_FILE}=ack --${IGNORE_FILE}=dBug.php --${IGNORE_FILE}=bootstrap.php.cache --${IGNORE_FILE}=model --${IGNORE_FILE}=load_insert --${IGNORE_FILE}=generateparams --${IGNORE_FILE}=generatelocations --${IGNORE_FILE}=generateinserts --${IGNORE_FILE}=countalltables --${IGNORE_FILE}=conflicts --${IGNORE_DIR}=AbsoluteUrlBundle --${IGNORE_DIR}=cache --${IGNORE_DIR}=vendor --${IGNORE_DIR}=bower_components  --${IGNORE_DIR}=node_modules --${IGNORE_DIR}=storage/debugbar  --${IGNORE_DIR}=.idea  --${IGNORE_DIR}=.git --${IGNORE_DIR}=storage/logs  --${IGNORE_DIR}=app/Stubs "
#
# COMPOSE IGNORE ONELINER - start
#
EXCLUDEFILE="--${IGNORE_FILE}="
EXCLUDEDIR="--${IGNORE_DIR}="
MOREIGNORE_FILES=""
[ -f .ersetzeignore_files ] && MOREIGNORE_FILES=$(<.ersetzeignore_files)
MOREIGNORE_DIRS=""
[ -f .ersetzeignore_dirs ] && MOREIGNORE_DIRS=$(<.ersetzeignore_dirs)

# echo "MOREIGNORE_FILES:${MOREIGNORE_FILES}"
# echo "MOREIGNORE_DIRS:${MOREIGNORE_DIRS}"
# exit 0

FILESTOEXCLUDE=".dir_bash_history
.gitignore
.ersetzeignore_dirs
.ersetzeignore_files
.nurignore_dirs
.nurignore_files
.tutorial
ack
bootstrap.php.cache
conflicts
composer.phar
countalltables
dBug.php
generateinserts
generatelocations
generateparams
load_insert
phpunit
${MOREIGNORE_FILES}"

DIRSTOEXCLUDE=".cargo
.nyc_output
.serverless
.tmp
.ecryptfs
.gvfs
.git
.idea
.vagrant
.servo
coverage
AbsoluteUrlBundle
app/Stubs
bower_components
node_modules
cache
.cache
dist
python
storage/debugbar
storage/logs
target
tmp
log
ports
app/Stubs
var/cache
var/logs
var/session
app/cache
app/logs
app/session
${MOREIGNORE_DIRS}"
# echo "FILESTOEXCLUDE:${FILESTOEXCLUDE}"
# echo "DIRSTOEXCLUDE:${DIRSTOEXCLUDE}"
# exit 0

IGNORELIST=""

    while read -r ONE_FILENAME; do
      [[ -z "${ONE_FILENAME}" ]] && continue  # if not empty
      IGNORELIST="${IGNORELIST} ${EXCLUDEFILE}${ONE_FILENAME}"
    done <<< "${FILESTOEXCLUDE}"
    while read -r ONE_DIRNAME; do
      [[ -z "${ONE_DIRNAME}" ]] && continue  # if not empty
      IGNORELIST="${IGNORELIST} ${EXCLUDEDIR}${ONE_DIRNAME}"
    done <<< "${DIRSTOEXCLUDE}"
# echo "IGNORELIST:${IGNORELIST}"
# exit 0
#
# COMPOSE IGNORE ONELINER - end
#


#
# COLORS - Output - Start
#
        # RESET_PROMPT="[38;5;231m"
        RESET_PROMPT="[0m"
#
# COLORS - Output - end
#

# S E E K I N G   I N S T A L L    C H E C K  - Results
# Results as
#             $SEEKER  seeker program selected form this priority sift, ag, ack, grep
#             $IGNORE_DIR  keyword used to ignore dir by program
#             $IGNORE_FILE  keyword used to ignore dir by program
#             $FILESCOMMAND  usually a dot (.) to indicate to search from (this) folder
#             $PRINTCOMMAND  the pipiing command to funel to results to replacer program
#             $IGNORELIST  construct of ignored files
#             halts execution if not found
#
SEEKING="$1";
echo "${reset} ${green} Finding ${reset} $SEEKING ${green}                 with  ${SEEKER} ."
echo "   ";

echo "   ";
echo "${reset} ${green} Seek ignoring $(echo ${IGNORELIST} | sed  "s@${EXCLUDEDIR}@@g" | sed  "s@${EXCLUDEFILE}@@g"  | sed  "s@ @,@g") with ${SEEKER} -- "
#
# S E E K I N G   I N S T A L L    C H E C K  - End
#


# echo "${cyan}  ack  --ignore=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" "
# echo "${cyan}  ag  --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" "
# echo "${cyan}  grep  --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs \"${SEEKING}\" "
echo "   ";
err_buff=$?;
# THIS IS GREP FOR LINUX
# ack  --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING"
# ag  --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING"
# grep  --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs "$SEEKING"
# THIS IS GREP FOR MAC
# grep  --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs -e "$SEEKING" *


### APPLIED CHANGE --- START
### APPLIED CHANGE --- START
### APPLIED CHANGE --- START
### APPLIED CHANGE --- START
APPLIED_CHANGE=0
function enter_escape_for_sed() {
  #sed ':a;N;$!ba;s/\n/0N33NT3R/g'  # GNU sed
  sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g'  #  cross-platform compatible synta>
  APPLIED_CHANGE=$?
} # end enter_escape_for_sed
function enter_decode() {
  sed 's/\\n/\n/g'
} # end enter_decode
function escape_slashes() {
    sed 's/\//\\\//g'
} # end escape_slashes
function escape_backslashes_for_sed() {
    sed 's/\\/\\\\/g'
} # end escape_backslashes_for_sed
function escape_quotes() {
    sed 's/\"/\\\"/g'
} # end escape_quotes
function escape_single_quotes() {
    sed "s/'/\\\'/g"
} # end escape_single_quotes
function escape_squared_open_brackets() {
    sed "s/\[/\\\[/g"
} # end escape_squared_open_brackets
function escape_squared_close_brackets() {
    sed "s/\]/\\\]/g"
} # end escape_squared_close_brackets
# DEBUG echo "SEEKING:$SEEKING"

INSEEKING=$(echo -n "${SEEKING}"|escape_backslashes_for_sed|escape_squared_open_brackets|escape_squared_close_brackets  | escape_quotes| escape_single_quotes )
TESTERINSEEKING=$(echo -n "${INSEEKING}" | enter_escape_for_sed)
# DEBUG echo "INSEEKING:$INSEEKING"


if [[ "${INSEEKING}" == "${TESTERINSEEKING}" ]] ; then
{
  APPLIED_CHANGE=0
}
else
{
  APPLIED_CHANGE=0
  if [[ -n "${TESTERINSEEKING}" ]] ; then
  {
    APPLIED_CHANGE=1
    SEEKING="${TESTERINSEEKING}"
  }
  fi
}
fi
# DEBUG
# DEBUG echo "SEEKING:$SEEKING"
#exit 0

### APPLIED CHANGE --- END
### APPLIED CHANGE --- END
### APPLIED CHANGE --- END
### APPLIED CHANGE --- END

### PERFORM NUR PIPE - START
### PERFORM NUR PIPE - START
### PERFORM NUR PIPE - START
### PERFORM NUR PIPE - START

  ##########             ##############                 ##                 ############               ##########             ##          ##
  ##########             ##############                 ##                 ############               ##########             ##          ##
##          ##           ##                           ##  ##               ##          ##           ##          ##           ##          ##
##          ##           ##                           ##  ##               ##          ##           ##          ##           ##          ##
##                       ##                         ##      ##             ##          ##           ##                       ##          ##
##                       ##                         ##      ##             ##          ##           ##                       ##          ##
  ##########             ##########               ##          ##           ############             ##                       ##############
  ##########             ##########               ##          ##           ############             ##                       ##############
            ##           ##                       ##############           ##      ##               ##                       ##          ##
            ##           ##                       ##############           ##      ##               ##                       ##          ##
##          ##           ##                       ##          ##           ##        ##             ##          ##           ##          ##
##          ##           ##                       ##          ##           ##        ##             ##          ##           ##          ##
  ##########             ##############           ##          ##           ##          ##             ##########             ##          ##
  ##########             ##############           ##          ##           ##          ##             ##########             ##          ##

### PERFORM NUR PIPE - START
### PERFORM NUR PIPE - START
### PERFORM NUR PIPE - START
### PERFORM NUR PIPE - START

if [[ $SEEKING == *"/"* ]]
then
{


echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}  "
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}
                err_buff=$?
#                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
else
{

echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}  "
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}
                err_buff=$?
#                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
fi

# If  | egrep "$SEEKING" &>/dev/null | returned an error....so it was... it was found/not found say it and stop execution for not found
# if [ ! $? -eq 0 ] ; then #mac
# if (( $? == 0 )) ;  then #work

################       ##############         ####          ####    ####        ####    ################
################       ##############         ####          ####    ####        ####    ################
####                 ####          ####       ####          ####    ######      ####    ####          ####
####                 ####          ####       ####          ####    ######      ####    ####          ####
####                 ####          ####       ####          ####    ##########  ####    ####          ####
####                 ####          ####       ####          ####    ##########  ####    ####          ####
############         ####          ####       ####          ####    ####  ####  ####    ####          ####
############         ####          ####       ####          ####    ####  ####  ####    ####          ####
####                 ####          ####       ####          ####    ####    ########    ####          ####
####                 ####          ####       ####          ####    ####    ########    ####          ####
####                 ####          ####       ####          ####    ####      ######    ####          ####
####                 ####          ####       ####          ####    ####      ######    ####          ####
####                   ##############           ##############      ####        ####    ################
####                   ##############           ##############      ####        ####    ################

# echo "err_buff=$err_buff"
# echo "PROCESSOR_ERROR=$PROCESSOR_ERROR"
if [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( $err_buff == 0 )); then
{
    msg_green "${green} FOUND !"
    echo "    ";
    FOUND=1
}
elif [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff == 0 ]; then
{
    msg_green "${green} FOUND !"
    echo "    ";
    FOUND=1
}
else
{
    msg_red "${red} SORRY NO FOUND OCCURENCES !"
    echo -e "${RESET}    ";
    FOUND=0
    exit 1;
}
fi



echo "   ";
echo "${yellow} ...";



######      #######     ######      #              #         #####      #######
######      #######     ######      #              #         #####      #######
#     #     #           #     #     #             # #       #     #     #
#     #     #           #     #     #             # #       #     #     #
#     #     #           #     #     #            #   #      #           #
#     #     #           #     #     #            #   #      #           #
######      #####       ######      #           #     #     #           #####
######      #####       ######      #           #     #     #           #####
#   #       #           #           #           #######     #           #
#   #       #           #           #           #######     #           #
#    #      #           #           #           #     #     #     #     #
#    #      #           #           #           #     #     #     #     #
#     #     #######     #           #######     #     #      #####      #######
#     #     #######     #           #######     #     #      #####      #######
# R E P L A C E    P A R T


# echo $0=./replace
IMPLACING="$2";
SEEKING_FOR_CONFIRM="$2";

# Keep this commands for reference DON'T DELETE  KEEP KEEP
# echo "${cyan}  ack -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" --print0 | xargs -0 sed  -i  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g"
# echo "${cyan}  ag -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs \"${SEEKING}\" --print0 | xargs -0 sed  -i  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g"
# echo "${cyan}  grep -l --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs \"${SEEKING}\" --print0 | xargs -0 sed  -i  -e s/\"${SEEKING}\"/\"${IMPLACING}\"/g"
# ack -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING" --print0 | xargs -0 sed  -i  -e s/"$SEEKING"/"$IMPLACING"/g
# ag -l --ignore-dir=vendor --ignore-dir=bower_components  --ignore-dir=node_modules --ignore-dir=storage/debugbar  --ignore-dir=storage/logs  --ignore-dir=app/Stubs "$SEEKING" --print0 | xargs -0 sed  -i  -e s/"$SEEKING"/"$IMPLACING"/g
# grep -l --exclude-dir=vendor --exclude-dir=bower_components  --exclude-dir=node_modules --exclude-dir=storage/debugbar  --exclude-dir=storage/logs  --exclude-dir=app/Stubs "$SEEKING" --print0 | xargs -0 sed  -i  -e s/"$SEEKING"/"$IMPLACING"/g
# Keep this commands for reference DON'T DELETE  KEEP KEEP


# echo "${reset} ${green} Replacing ${reset} $SEEKING ${green} for ${reset} $IMPLACING  ${green} with Sed."
echo -e "${reset} ${green} Replacing ${reset} $SEEKING ${green} for ${reset} $IMPLACING  ${green} with  ${SEEKER}."
if [[ $REPLACER == "sed" ]] ; then
    {
    # check operation systems
    (
      if [[ "$(uname)" == "Darwin" ]] ; then
        # Do something under Mac OS X platform
        echo " "
      elif [[ "$(cut -c1-5 <<< "$(uname -s)")" == "Linux" ]] ; then
        # Do something under GNU/Linux platform
        echo " "
      elif [[ "$(cut -c1-10 <<< "$(uname -s)")" == "MINGW32_NT" ]] || [[ "$(cut -c1-10 <<< "$(uname -s)")" == "MINGW64_NT" ]] ; then
        # Do something under Windows NT platform
        msg_red "${green} ${red} WARNING INSIDE WINDOWS Sed locks you out of your file, and the solution is that you have to recreate the file again."
        # nothing here
      fi
    )
    }
fi
echo "   ";


echo "${yellow} REPLACING NOW !        . . . using ${REPLACER} command ";

# REF # http://stackoverflow.com/questions/11245144/replace-whole-line-containing-a-string-using-sed
# The accepted answer did not work for me for several reasons:
#
#  โข my version of sed does not like -i with a zero length extension
#  โข the syntax of the c\ command is weird and I couldn't get it to work
#  โข I didn't realize some of my issues are coming from unescaped slashes
#
# So here is the solution I came up with which I think should work for most cases:
#
### APPLIED IMPLACING CHANGE --- START
### APPLIED IMPLACING CHANGE --- START
### APPLIED IMPLACING CHANGE --- START
### APPLIED IMPLACING CHANGE --- START
APPLIED_ENTER=0
function enter_escape_for_sed() {
  #sed ':a;N;$!ba;s/\n/0N33NT3R/g'  # GNU sed
  sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g'  #  cross-platform compatible syntax which works with BSD sed
  APPLIED_ENTER=$?
} # end enter_escape_for_sed
function enter_decode() {
  sed 's/\\n/\n/g'
} # end enter_decode
function escape_slashes() {
    sed 's/\//\\\//g'
} # end escape_slashes
function escape_quotes() {
    sed 's/\"/\\\"/g'
} # end escape_quotes
function escape_double_quotes() {
    sed 's/"/\\\"/g'
} # end escape_double_quotes
function escape_single_quotes() {
    sed "s/'/\\\'/g"
} # end escape_single_quotes
function escape_squared_bracket_start() {
    sed "s/\[/\\\[/g"
}
function escape_squared_bracket_end() {
    sed "s/\]/\\\]/g"
}
function escape_curly_bracket_start() {
    sed "s/[{]/\\\{/g"
}
function escape_curly_bracket_end() {
    sed "s/[}]/\\\}/g"
}
function escape_ampersands() {
    sed "s/[&]/\\\&/g"
}

function change_line() {
    # So the sample usage to fix the problem posed:
    # change_line "TEXT_TO_BE_REPLACED" "This line is removed by the admin." yourFile

    local OLD_LINE_PATTERN=$1; shift
    local NEW_LINE=$1; shift
    local FILE=$1

    local NEW=$(echo "${NEW_LINE}" | escape_slashes)
    sed -i .bak '/'"${OLD_LINE_PATTERN}"'/s/.*/'"${NEW}"'/' "${FILE}"
    mv "${FILE}.bak" /tmp/
} # end change_line

# OLD_LINE_PATTERN=$SEEKING;
# NEW_LINE=$2;
# FILE=$3
# DEBUG
# DEBUG echo  "1 IMPLACING:${IMPLACING}"
# escape_slashes has to be the last or it will fail on other replacements after
IMPLACING="$(echo -n "${IMPLACING}"  | escape_quotes| escape_single_quotes | escape_ampersands | escape_curly_bracket_end | escape_curly_bracket_start| escape_squared_bracket_end | escape_squared_bracket_start  | escape_slashes)"
# echo  "2 IMPLACING:${IMPLACING}"
TESTENTERIMPLACING="$(echo -n "${IMPLACING}" | enter_escape_for_sed)"
# echo  "3 IMPLACING:${IMPLACING}"

if [[ "${IMPLACING}" == "${TESTENTERIMPLACING}" ]] ; then
{
  APPLIED_ENTER=0
}
else
{
  APPLIED_ENTER=0
  if [[ -n "${TESTENTERIMPLACING}" ]] ; then
  {
    APPLIED_ENTER=1ยง
    IMPLACING=$TESTENTERIMPLACING
  }
  elif [[ -n "${IMPLACING}" ]] ; then
  {
    APPLIED_ENTER=1
    IMPLACING="${IMPLACING}"
  }
  fi
}
fi

# TESTENTERIMPLACING="$(sed "s/'/\\\'/g" <<< "${IMPLACING}")"


# if [[ "${IMPLACING}" == "${TESTENTERIMPLACING}" ]] ; then
# {
#   APPLIED_ENTER=0
# }
# else
# {
#   APPLIED_ENTER=0
#   if [[ -n "${TESTENTERIMPLACING}" ]] ; then
#   {
#     APPLIED_ENTER=1ยง
#     IMPLACING=$TESTENTERIMPLACING
#   }
#   elif [[ -n "${IMPLACING}" ]] ; then
#   {
#     APPLIED_ENTER=1
#     IMPLACING="${IMPLACING}"
#   }
#   fi
# }
# fi

# DEBUG: 
# 
# DEBUG=1 ersetze "ALLOWED_HOSTS = [" "ALLOWED_HOSTS = ['0.0.0.0', 'localhost', '127.0.0.1',"
# 
(( DEBUG )) && echo  "4          IMPLACING:${IMPLACING}"
(( DEBUG )) && echo  "4 TESTENTERIMPLACING:${TESTENTERIMPLACING}"

function escape_backslashes_for_sed() {
    sed 's/\\/\\\\/g'
} # end escape_backslashes_for_sed

(( DEBUG )) && echo -e  "5          SEEKING:$SEEKING"

SEEKERNEW=$(echo -n "${SEEKING}"  | escape_backslashes_for_sed )
TESTENTERSEEKING="$(echo -n "${SEEKERNEW}" )"
APPLIED_ENTER_SEEK=0
if [[ "${SEEKING}" == "${TESTENTERSEEKING}" ]] ; then
{
  APPLIED_ENTER_SEEK=0
}
else
{
  APPLIED_ENTER_SEEK=0
  if [[ -n "${TESTENTERSEEKING}" ]] ; then
  {
    APPLIED_ENTER_SEEK=1
    SEEKING=$TESTENTERSEEKING
  }
  fi
}
fi


SEEKER_FOR_SED="${SEEKING}"
TEST_SEEKER_FOR_SED="$(echo -n "${SEEKING}"  | escape_quotes| escape_single_quotes | escape_ampersands | escape_curly_bracket_end | escape_curly_bracket_start| escape_squared_bracket_end | escape_squared_bracket_start  | escape_slashes)"
# TEST_SEEKER_FOR_SED=$(echo -n "${TEST_SEEKER_FOR_SED}"  | escape_backslashes_for_sed )

APPLIED_ENTER_SEEK=0
if [[ "${SEEKING}" == "${TEST_SEEKER_FOR_SED}" ]] ; then
{
  APPLIED_ENTER_SEEK=0
}
else
{
  APPLIED_ENTER_SEEK=0
  if [[ -n "${TEST_SEEKER_FOR_SED}" ]] ; then
  {
    APPLIED_ENTER_SEEK=1
    SEEKER_FOR_SED=$TEST_SEEKER_FOR_SED
  }
  fi
}
fi


(( DEBUG )) && echo  "5      SEEKER_FOR_SED:${SEEKER_FOR_SED}"
(( DEBUG )) && echo  "5 TEST_SEEKER_FOR_SED:${TEST_SEEKER_FOR_SED}"


# (( DEBUG )) && exit 0

### APPLIED IMPLACING CHANGE --- END
### APPLIED IMPLACING CHANGE --- END
### APPLIED IMPLACING CHANGE --- END
### APPLIED IMPLACING CHANGE --- END

err_buff=0

#
# REPLACE - start
#
# If it contains forward slashes then use a different seeker
if [[ $SEEKING == *"/"* || $IMPLACING == *"/"* ]]; then
# contains slashes
{
  if [[ "${REPLACER}" == "sed" ]] ; then
  # sed
  {
    if [[ "${REPLACERGNU}" == "YES" ]] ; then
    # sed GNU
    {
            echo "${yellow} sed GNU ";
            # Get list and scroll through the list
            # FILES=$(${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST})
            # echo "FILES FOUND: $FILES"
            # Scroll the list and make individual replacements
            # while read -r FILE; do
            #  {
            #     sed -i -e s/"$SEEKING"/"$IMPLACING"/g "$FILE"
            #  }
            # done <<< "$FILES"


            echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i  -e s\"${SEEKER_FOR_SED}\"\"${IMPLACING}\"g {}"
                            ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i  -e s"$SEEKER_FOR_SED""$IMPLACING"g {} | ${SEEKER} "$SEEKER_FOR_SED" ${FILESCOMMAND}  &>/dev/null
                     err_buff=$?
    }
    else
    # sed mac
    # MAC REPLACER Has to HAVE A FILENAME.EXTENSION provided for the -i (inplace) option
    {
            echo "${yellow} sed MAC ";
            # Sample use: ${THISSCRIPTNAME} /usr/bin/env\ bash  /bin/bash
            # echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs -0 sed -i'.sedbak'  -e s\"${SEEKER_FOR_SED}\"\"${IMPLACING}\"g"
            echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i'.sedbak'  -e s\"${SEEKER_FOR_SED}\"\"${IMPLACING}\"g {}"
            #                ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs -0 sed -i'.sedbak'  -e s"$SEEKER_FOR_SED""$IMPLACING"g | ${SEEKER} "$SEEKER_FOR_SED" ${FILESCOMMAND}  &>/dev/null
                            ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i'.sedbak'  -e s"$SEEKER_FOR_SED""$IMPLACING"g {} | ${SEEKER} "$SEEKER_FOR_SED" ${FILESCOMMAND}  &>/dev/null
                               err_buff=$?
    }
    fi
  }
  else
  # ex
  # REF: http://askubuntu.com/questions/20414/find-and-replace-text-within-a-file-using-commands
  {
        echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {}  ex +s\"$SEEKER_FOR_SED\"\"$IMPLACING\" -cwq {} "
                        ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {}  ex +s"$SEEKER_FOR_SED""$IMPLACING" -cwq {}
                    err_buff=$?
      }
    fi
  }
  else
  # contains not slashes in the expresion
  {
    if [[ "${REPLACER}" == "sed" ]] ; then
      # sed
      {
        if [[ "${REPLACERGNU}" == "YES" ]] ; then
          # sed GNU
          {
            echo "${yellow} sed GNU "
            # echo "Test"
            # echo ersetze  velophil.test- velophil-berlin-
            # echo -en "  SEEKING:"
            # echo -n "\"${SEEKING}\" == \"velophil.test-\"  "
            # if [[ "${SEEKING}" == "velophil.test-" ]] ; then
            # {
            #  echo -e "${green}passed"
            # }
            # else
            # {
            #  echo -e "${red}         failed"
            # }
            # fi
            # echo -en "IMPLACING:"
            # echo -n "\"${IMPLACING}\" == \"velophil-berlin-\"  "
            # if [[ -n "${IMPLACING}" ]] && [[ "${IMPLACING}" == "velophil-berlin-" ]]; then
            # {
            #  echo -e "${green}passed"
            # }
            # else
            # {
            #  echo -e "${red}            failed"
            # }
            # fi
            # exit 0
            # Get list and scroll through the list
            # FILES=$(${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST})
            # echo "FILES FOUND: $FILES"
            # Scroll the list and make invidual replacements
            # while read -r FILE; do
            #  {
            #     sed -i -e s/"$SEEKING"/"$IMPLACING"/g "$FILE"
            #  }
            # done <<< "$FILES"

            echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i -e s/\"${SEEKER_FOR_SED}\"/\"${IMPLACING}\"/g {}"
                            ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i -e s/"$SEEKER_FOR_SED"/"$IMPLACING"/g {} | ${SEEKER} "$SEEKER_FOR_SED" ${FILESCOMMAND}  &>/dev/null
                           err_buff=$?
          }
        else
          # sed 2.5.1-FreeBSD mac
          # MAC REPLACER Has to HAVE A FILENAME.EXTENSION provided for the -i (inplace) option
          {
            echo "${yellow} sed MAC ";
            echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i'.sedbak'  -e s/\"${SEEKER_FOR_SED}\"/\"${IMPLACING}\"/g {}"

                            ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {} sed -i'.sedbak'  -e s/"$SEEKER_FOR_SED"/"$IMPLACING"/g {} | ${SEEKER} "$SEEKER_FOR_SED" ${FILESCOMMAND} &>/dev/null
                           err_buff=$?
          }
        fi
      }
    else
      # ex
      {
        # VIM ex To find and replace all occurrences of case insensitive 'eth1' with 'br1', enter:
        echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {}  ex +%s/\"$SEEKER_FOR_SED\"/\"$IMPLACING\"/gi -cwq {} "
                        ${SEEKER} "$SEEKING"     ${FILESCOMMAND} ${PRINTCOMMAND} ${IGNORELIST}   | xargs $XARGSCOMMAD -I {}  ex +%s/"$SEEKER_FOR_SED"/"$IMPLACING"/gi -cwq {}
                        err_buff=$?
      }
    fi
  }
fi
#echo "    ";
#
# REPLACE - end
#
##########     ##########  ##########    ##              ####        ########    ##########  ##########
##########     ##########  ##########    ##              ####        ########    ##########  ##########
##        ##   ##          ##        ##  ##            ##    ##    ##        ##  ##          ##        ##
##        ##   ##          ##        ##  ##            ##    ##    ##        ##  ##          ##        ##
##        ##   ########    ##        ##  ##          ##        ##  ##            ########    ##        ##
##        ##   ########    ##        ##  ##          ##        ##  ##            ########    ##        ##
##########     ##          ##########    ##          ############  ##            ##          ##        ##
##########     ##          ##########    ##          ############  ##            ##          ##        ##
##      ##     ##          ##            ##          ##        ##  ##        ##  ##          ##        ##
##      ##     ##          ##            ##          ##        ##  ##        ##  ##          ##        ##
##        ##   ##########  ##            ##########  ##        ##    ########    ##########  ##########
##        ##   ##########  ##            ##########  ##        ##    ########    ##########  ##########
#
# If  | egrep "$SEEKING" &>/dev/null | returned an error....so it was... it was found/not found say it and stop execution for not found
#if [ $? == 0 ]; then
#if (( $? != 0 )) ;  then  #Inverse respose It will be EMPTY $? when replacements where made!
(( DEBUG )) && echo -e "       err_buff:$err_buff"
(( DEBUG )) && echo -e "PROCESSOR_ERROR:$PROCESSOR_ERROR"
(( DEBUG )) && echo -e "    REPLACERGNU:$REPLACERGNU"
(( DEBUG )) && echo -e "       REPLACER:$REPLACER"

if [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( err_buff != 0 )); then
    { 
    msg_green "${green} REPLACED !"
    echo "    ";
    FOUND=1
    }
elif [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] ; then
    { 
    if [[ "${REPLACER}" == "sed" &&  "${REPLACERGNU}" == "NO" ]] ; then
        {
        if [ $err_buff == 0 ] ; then
            {
            msg_green "${green} REPLACED !"
            echo "    ";
            FOUND=1    
            }
        else 
            {
            msg_red "${red} SORRY NO REPLACEMENTS MADE !"
            echo "    ";
            exit 0;
            FOUND=0
            }
        fi
        }
    else 
        {
        if [ $err_buff == 0 ] ; then
            {
            msg_green "${green} REPLACED !"
            echo "    ";
            FOUND=1    
            }
        else 
            {
            msg_red "${red} SORRY NO REPLACEMENTS MADE !"
            echo "    ";
            exit 0;
            FOUND=0
            }
        fi
        }
    fi
    }
else
    {
    msg_red "${red} SORRY NO REPLACEMENTS MADE !"
    echo "    ";
    exit 0;
    FOUND=0
    }
fi


echo "${green}  SEEKING ${yellow}  CONFIRM ${green} NEW VALUES NOW :   ";
echo "    ";
err_buff=0
#SEEKING=$IMPLACING;
SEEKING="$SEEKING_FOR_CONFIRM";
# echo "applied enter: ${APPLIED_ENTER}"
# if [[ "${APPLIED_ENTER}" != 0 ]]; then
# {
#   SEEKING=$(echo $IMPLACING | enter_decode);
# }
# fi

if [[ $SEEKING == *"/"* ]]
then
{

echo "5 SEEKING:$SEEKING"

echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}  "
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}
#                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
else
{

echo "${cyan}   ${SEEKER} \"${SEEKING}\" ${FILESCOMMAND} ${IGNORELIST}  "
                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}
#                ${SEEKER} "$SEEKING" ${FILESCOMMAND}     ${IGNORELIST}   | ${SEEKER} "$SEEKING" ${FILESCOMMAND}  &>/dev/null
}
fi
 #######       #####     ###        ###   ##########  ###   ########       ###        ###   #########  ########
#########      #####     ###        ###   ##########  ###   ########       ###        ###   #########  ########
##      ##   ##     ##   #####      ###   ###         ###   ###     ##     #####    #####   ##         ###     ##
##      ##   ##     ##   #####      ###   ###         ###   ###     ###    #####    #####   ##         ###     ##
##           ##     ##   ###  ##    ###   ########    ###   ###     ###    ###  ####  ###   #######    ###     ##
##           ##     ##   ###  ##    ###   ########    ###   ###     ##     ###  ####  ###   #######    ###     ##
##           ##     ##   ###    ##  ###   ###         ###   ########       ###        ###   ##         ###     ##
##           ##     ##   ###    ##  ###   ###         ###   ########       ###        ###   ##         ###     ##
##      ##   ##     ##   ###      #####   ###         ###   ###   ##       ###        ###   ##         ###     ##
##      ##   ##     ##   ###      #####   ###         ###   ###   ###      ###        ###   ##         ###     ##
#########     #######    ###        ###   ###         ###   ###     ###    ###        ###   #########  ########
 #######       #####     ###        ###   ###         ###   ###     ###    ###        ###   #########  ########

# INVERSE SWITCH If  | egrep "$SEEKING" &>/dev/null | returned an error....so it was... it was found/not found say it and stop execution for not found
# REF: https://ubuntuforums.org/showthread.php?t=2172828
#if [ "$?" = -1 ] ; then
#        zenity --error \
#          --text="Update error."
#fi
#exit 0##
#
#It should be replaced with the following:
#Code:#
#
#(( $? != 0 )) && zenity --error --text="Update error."#
#
#exit 0


# REPEATED in remove script but here applied to silence mode
# so it does not ask for Y/N confirmation
# PLUS is one less extra dependency external to this script
function removal_with_subdirectories() {


# Using mv
#
#   or
# REF: http://stackoverflow.com/questions/7190965/how-to-move-and-overwrite-all-files-from-one-directory-to-another
# It's also possible by using rsync, for example:
#
# rsync -va --delete-after src/ dst/
# where:
#
# -v, --verbose: increase verbosity
# -a, --archive: archive mode; equals -rlptgoD (no -H,-A,-X)
# --delete-after: delete files on the receiving side be done after the transfer has completed
# If you've root privileges, prefix with sudo to override potential permission issues.
    local CURCOMMAND FILESFOUND1 FILESFOUND2 FILESFOUND3 FILESFOUND4 FILESFOUND
    local REPLACERGNU
    REPLACERGNU="${1}"
    local SEEKING
    SEEKING="${*:2}"
    [ -z ${SEEKING} ] && return;
    CURCOMMAND="find . -name \"*${SEEKING}*\" -print0  | xargs -0 -I {} mv {} /tmp/ "
    # dotglob:
    #      If set, Bash includes filenames beginning with a โ.โ in the results of filename expansion.
    shopt -s dotglob   # Notice this is a bash script #!/usr/bin/env bash as stated on the header
    #
    # find . -name "*${SEEKING}*" -print0 | xargs -0 rm
    #    This echo  $(echo "${CURCOMMAND}")   is work around ...if removed
    #      it outputs only this    ====    CURCOMMAND  ==== "
    #
    CURCOMMAND="find . -name \"${SEEKING}\" -print0  | xargs -0 -I {} mv {} /tmp/ "
    echo -e "\033[38;5;27m ====   \033[38;5;214m $(echo "${CURCOMMAND}")           \033[38;5;27m     ====";
    FILESFOUND1="$(find . -name "${SEEKING}")"

    CURCOMMAND="find . -name \"${SEEKING}*\" -print0  | xargs -0 -I {} mv {} /tmp/ "
    echo -e "\033[38;5;27m   ====   \033[38;5;214m $(echo "${CURCOMMAND}")        \033[38;5;27m   ====";
    FILESFOUND2="$(find . -name "${SEEKING}*")"

    CURCOMMAND="find . -name \"*${SEEKING}\" -print0  | xargs -0 -I {} mv {} /tmp/ "
    echo -e "\033[38;5;27m     ====   \033[38;5;214m $(echo "${CURCOMMAND}")    \033[38;5;27m   ====";
    FILESFOUND3="$(find . -name "*${SEEKING}")"

    CURCOMMAND="find . -name \"*${SEEKING}*\" -print0  | xargs -0 -I {} mv {} /tmp/ "
    echo -e "\033[38;5;27m       ====   \033[38;5;214m $(echo "${CURCOMMAND}")\033[38;5;27m  ====";
    FILESFOUND4="$(find . -name "*${SEEKING}*")"
    FILESFOUND="${FILESFOUND1}
${FILESFOUND2}
${FILESFOUND3}
${FILESFOUND4}"
    if [[ -z "${FILESFOUND-x}" ]] ; then
      echo -e "\033[38;5;27m         ====   \033[38;5;214m Nothing found !\033[38;5;27m  ===="
      return;
    fi
    # echo -e "\033[38;5;147m "
    # echo "${FILESFOUND} "
    # echo -e "\n"
    #find . -name "*${SEEKING}*" -print0  | xargs -0 -I {} mv {} /tmp/
    local ONE_FULLPATH_FILENAME ONE_FULLPATH_FILENAME JUST_FILENAME
    while read -r ONE_FULLPATH_FILENAME; do
      # if not empty
      [ -z ${ONE_FULLPATH_FILENAME} ] && continue
      JUST_FILENAME=$(basename "${ONE_FULLPATH_FILENAME}")
      echo -e "\033[38;5;27m ..copying...  \033[38;5;214m $(echo "cp -Rrf ${ONE_FULLPATH_FILENAME} /tmp/")       \033[38;5;27m      ";
      if [[ "${REPLACERGNU}" == "YES" ]] ; then
      # cp GNU
      {
        echo "${yellow} cp GNU ";
        cp -Rrf "${ONE_FULLPATH_FILENAME}" /tmp/
      }
      else
      # cp mac
      {
        echo "${yellow} cp MAC ";
        cp -rf "${ONE_FULLPATH_FILENAME}" /tmp/
      }
      fi
      echo -e "\033[38;5;27m ..cleaning..  \033[38;5;214m $(echo "rm -rf ${ONE_FULLPATH_FILENAME} ")       \033[38;5;27m      ";
      rm -rf "${ONE_FULLPATH_FILENAME}"
      #echo -e "\033[38;5;27m ..removing..   \033[38;5;214m $(echo "rm -rf ${ONE_FULLPATH_FILENAME}")       \033[38;5;27m      ";
      #rm -rf """${ONE_FULLPATH_FILENAME}"""

      echo -e "\033[38;5;27m  and moved to /tmp/           \033[38;5;214m";
      echo " ";
    done <<< "$(cut -c 3- <<<"${FILESFOUND}" | sort | uniq)"
} # end removal_with_subdirectories




#if (( $? == 0 )) ;  then #work
#if [ ! $? == 0 ]; then #mac
err_buff=$?
# echo "err_buff=$err_buff"
if [[ "${PROCESSOR_ERROR}" == *"INTEL"* ]] && (( err_buff == 0 )); then
    {
    echo "    ";
    echo "${cyan} REPLACE CONFIRMED ${green} FOUND !"
    if [[ "${REPLACER}" == "sed" &&  "${REPLACERGNU}" == "NO" ]] ; then
      removal_with_subdirectories "${REPLACERGNU}"  .sedbak
      # removal_with_subdirectories "${REPLACERGNU}"  "${SEEKING}"
      #  remove .sedbak
    fi
    echo "    ";
    }
elif [[ "${PROCESSOR_ERROR}" == *"MAC"* ]] && [ $err_buff == 0 ]; then
    {
    echo "    ";
    echo "${cyan} REPLACE CONFIRMED ${green} FOUND !"
    if [[ "${REPLACER}" == "sed" &&  "${REPLACERGNU}" == "NO" ]] ; then
      removal_with_subdirectories "${REPLACERGNU}"  .sedbak
      # removal_with_subdirectories "${REPLACERGNU}"  "${SEEKING}"
      #  remove .sedbak
    fi
    echo "    ";
    }
else
    {
    msg_red "${red} REPLACEMENT FAILED !"
    echo "    ";
    exit 1;
    }
fi


echo "   ";
echo "${yellow} ...";
