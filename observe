#!/usr/bin/env bash

set -u
#
# C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --Start
#
test_positives(){
  KIND=""
  local -i _err=0
  if ls werwerwerwerwerwerwerwerwerwerwerr >/dev/null 2>&1; then
    _err=$?
    if (( _err == 0 )) ;  then  # Intel processor
      KIND="INTEL"
    fi
    if [ $_err == 0 ]; then   # Mac Intel processor
      KIND="${KIND}MAC"
    fi
  else
    if (( _err == 0 )) ;  then  # Intel processor
      KIND="INTEL"
    fi
    if [ $_err == 0 ]; then   # Mac Intel processor
      KIND="${KIND}MAC"
    fi
  fi
  echo "${KIND}"
}
PROCESSOR_ERROR=$(test_positives)
# DEBUG MACPOSITIVE MACPOSITIVE echo "${PROCESSOR_ERROR}"
# DEBUG MACPOSITIVE exit 1
#
# C H E C K   H O W   C O M P U T E R   H A N D L E S   E R R O R S   --End
#

#
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  --Start
#
check_replacer () {
  local REPLACER="$1"
  if command -v "${REPLACER}" >/dev/null 2>&1; then
    # It looks installed
    # .. is it working properly
    # msg_green " ${1} INSTALLED."

    #stdout UND stderr -capture  REF: https://www.thomas-krenn.com/de/wiki/Bash_stdout_und_stderr_umleiten
    ${REPLACER}  --version &> /tmp/ersetze_test_${REPLACER}.txt
    # shellcheck disable=SC2155
    local PROPERLYWORKING=$(cat /tmp/ersetze_test_${REPLACER}.txt)

    if [[ "$PROPERLYWORKING" == *"dyld:"* ]]; then { echo "error"; return;} fi
    if [[ "$PROPERLYWORKING" == *"GNU"* ]]; then { echo "GNU"; return;} else { echo "MAC";return;} fi
    echo "checked";
    return;
  else
    # msg_red "${GREEN} ${RED} CANNOT REPLACE ...${1} IS MISSING ";
    # msg_red " NEED TO INSTALL ${1}.       Linux:    sudo apt-get install ${1}         Mac:     brew install ${1}   "
    echo "install";
    return;
  fi
}
function msg_install() {
  msg_red "${GREEN} ${RED} CANNOT REPLACE ...${1} IS MISSING ";
  msg_red " NEED TO INSTALL ${1}.       Linux:    sudo apt-get install ${1}         Mac:     brew install ${1}   "
}
# REPLACER="sed";
# Try vim's ex ..broke here grrr TODO research how to implement doing erestese_indatei /images/projects/ images/projects index.html did not work at all
REPLACER="sed"; # changed to sed
VALIDREPLACER=$(check_replacer "${REPLACER}")


if [[ $VALIDREPLACER == "error" ]] ; then
  msg_red "Error with replacer ${REPLACER}"
  msg_red " - Error:"
  cat /tmp/ersetze_test_${REPLACER}.txt
   rm /tmp/ersetze_test_${REPLACER}.txt
fi

if [[ $VALIDREPLACER == "install" ]] ; then
  msg_install "${REPLACER}"
fi
rm /tmp/ersetze_test_${REPLACER}.txt

# TODO - Remove Repetition HERE
# ? empty still
if [[ $VALIDREPLACER == "install" || $VALIDREPLACER == "error"  ]] ; then
  REPLACER="sed";
  VALIDREPLACER=$(check_replacer "${REPLACER}")

  if [[ $VALIDREPLACER == "error" ]] ; then
    msg_red "Error with replacer ${REPLACER}"
    msg_red " - Error:"
    cat /tmp/ersetze_test_${REPLACER}.txt
     rm /tmp/ersetze_test_${REPLACER}.txt
    exit 1;
  fi

  if [[ $VALIDREPLACER == "install" ]] ; then
    msg_install "${REPLACER}"
    rm /tmp/ersetze_test_${REPLACER}.txt
    exit 1;
  fi
fi



REPLACERGNU="NO"
if [[ $VALIDREPLACER == "GNU" ]] ; then
{
  REPLACERGNU="YES"
}
fi


# one more check for gsed from brew in macs
if [[ $REPLACERGNU == "NO" ]] ; then
{
  if command -v gsed >/dev/null 2>&1 ; then
  {
    REPLACERGNU="YES"
    REPLACER="gsed"
  }
  fi
}
fi


# Test
# echo "REPLACERGNU: $REPLACERGNU"
# echo "VALIDREPLACER: $VALIDREPLACER"
# exit
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  -- RESULTS
# Results as
#             $REPLACERGNU  NO OR YES
#             $REPLACERGNU  ex or sed
#             halts execution if not found
#
# C H E C K   R E P L A C E   F U N C T I O N S   I N S T A L L E D  -- End



[ -z ${1-} ] && echo "Expected at least one parameter for filename to observe!." && exit 1
typeset pwd_backslash_escaped_for_sed=$(pwd | sed 's@/@\\/@g')
function file_extension() {
  #
  # Outputs the file extension given a file name
  #
  # $1 = Filename.ext:linenummer
  #
  # Usage: extension=$(file_extension "foo/bar.baz")
  #   Result: $extension ==> "baz"
  #
  #
  local test_value=$(echo "${1##*.}")
  if [[ "${test_value}" == *":"* ]] ; then
  {
    echo "${test_value}" | cut -d":" -f1
  }
  else
  {
    echo "${test_value}"
  }
  fi
} # end file_extension

function _trap_on_INT(){
  local -ir __trapped_INT_num="${2:-0}"
  echo -e "\\n \033[01;7m*** 7 INT TRAP $THISSCRIPTNAME \\n${BASH_SOURCE}:${BASH_LINENO[-0]} ${FUNCNAME[1]}() \\n$0:${BASH_LINENO[1]} ${FUNCNAME[2]}()  \\n$0:${BASH_LINENO[2]} ${FUNCNAME[3]}() \\n INT ...\033[0m  \n \n "
  echo ". ${1}"
  echo ". INT  ${__trapped_INT_num}  "
  echo ". caller $(caller) "
  echo ". ${BASH_COMMAND}"
  local -r __caller=$(caller)
  local -ir __caller_line=$(echo "${__caller}" | cut -d' ' -f1)
  local -r __caller_script_name=$(echo "${__caller}" | cut -d' ' -f2)
  awk 'NR>L-10 && NR<L+10 { printf "%-10d%10s%s\n",NR,(NR==L?"☠ » » » > ":""),$0 }' L="${__caller_line}" "${__caller_script_name}"

  # $(eval ${BASH_COMMAND}  2>&1; )
  # echo -e " ☠ ${LIGHTPINK} Offending message:  ${__bash_error} ${RESET}"  >&2
  exit ${__trapped_INT_num}
} # end _trap_on_INT
# trap  '_trap_on_INT $0 "${?}" LINENO BASH_LINENO FUNCNAME BASH_COMMAND $FUNCNAME $BASH_LINENO $LINENO   $BASH_COMMAND'  INT ERR

function _ignore_ruby_list(){
  # Sample use
  #  _ignore_ruby_list "${one-}"
  # _err=$?
  # [ ${_err} -gt 0 ] && continue # skip ignored files

  local file_to_test="${1}"
  local -i _found=0
  local ONE_FILENAME FILESTOEXCLUDE="
config/brakeman.ignore
"
  while read -r ONE_FILENAME; do
  {
    [[ -z "${ONE_FILENAME}" ]] && continue # skip if empty
    echo "Comparing ${ONE_FILENAME} vs ${file_to_test}"
    if [[ "${ONE_FILENAME}" == "${file_to_test}" ]] ; then
    {
      _found=1
      echo " \___ ig matched"
      break
    }
    fi
  }
  done <<< "${FILESTOEXCLUDE}"
  return ${_found}
} # end _ignore_ruby_list

function _is_duplicated(){
  # Sample use
  #  _is_duplicated "${1}" "${@:2}"
  #  _is_duplicated "Gemfile" "
  # config/brakeman.ignore
  # "
  # _err=$?
  # [ ${_err} -gt 0 ] && continue # skip duplicated files

  local file_to_test="${1}"
  local -i _found=0
  local ONE_FILENAME FILESTOEXCLUDE="${*:2}"
  while read -r ONE_FILENAME; do
  {
    [[ -z "${ONE_FILENAME}" ]] && continue # skip if empty
    echo "Comparing ${ONE_FILENAME} vs ${file_to_test}"
    if [[ "${ONE_FILENAME}" == "${file_to_test}" ]] ; then
    {
      _found=1
      echo " \___ dup matched"
      break
    }
    fi
  }
  done <<< "${FILESTOEXCLUDE}"
  return ${_found}
} # end _is_duplicated

function _main(){
  # set -exu
  local -i _err=0
  local file_to_observe="${1-}"
  local extension_to_observe=$(file_extension "${1-}")
  local observe_one_line=""
  if ( grep -q ":"  <<< "${file_to_observe}" ) ; then
  {
    observe_one_line="${file_to_observe}"
    local cut_file_number="$(cut -d: -f1 <<< "${file_to_observe}" )"
    extension_to_observe=$(file_extension "${cut_file_number:-}")
    file_to_observe="${cut_file_number}"
  }
  fi
  local extra_args_to_run="${*:2}"
  local prefix_to_run=""
  local file_to_watch="\"./\""
  local _filename=${file_to_observe##*/}          # get only last filename
  local _script_name=".${_filename}.watch.test.bash"
  local _rubocops=""
  local _rpec_file="watch(%r{^${_filename}\$})"
  local replacer_colors_prefix=$(cat <<-EOF
#!/usr/bin/env bash
# set -exu
pathpat="(/[^/]*)+:[0-9]+"
ccred=\$(echo -e "\033[0;31m")
ccyellow=\$(echo -e "\033[0;33m")
ccend=\$(echo -e "\033[0m")
# sed -E
# -e "/[Ee]rror[: ]/ s%\$pathpat%\$ccred&\$ccend%g"
# -e "/[Ww]arning[: ]/ s%\$pathpat%\$ccyellow&\$ccend%g"

EOF
)
# echo "${replacer_colors_prefix}"
# exit 0
  local replacer_colors_sufix2=""
  local replacer_colors_sufix3=""
  local replacer_colors_sufix=$(cat <<-EOF
          | ${REPLACER} --unbuffered '/\ process\ jobs\ in\ this\ environment/d' \\
        | ${REPLACER} --unbuffered '/Top\ level\ /d' \\
        | ${REPLACER} --unbuffered '/DEPRECATION WARNING..desired_principal_rate_change_amount=/d' \\
        | ${REPLACER} --unbuffered '/app.commands.loan.applications.create.rb.../d' \\
        | ${REPLACER} --unbuffered '/block....levels/d' \\
        | ${REPLACER} --unbuffered '/\ warning:\ already\ initialized\ constant/d' \\
        | ${REPLACER} --unbuffered '/\ was\ here/d' \\
      | ${REPLACER} --unbuffered 's/\ on\ line\ /:/g' \\
      | ${REPLACER} --unbuffered 's/:\ line\ /:/g' \\
      | ${REPLACER} --unbuffered 's/\ No\ such\ file\ or\ directory\ in\ /\ in\ \o033[38;5;213m/g' \\
      | ${REPLACER} --unbuffered 's/\,\ no\ offenses\ /\,\ \o033[01;32m no\ offenses\ \o033[0m/g' \\
      | ${REPLACER} --unbuffered 's/\ examples\,\ 0\ failures/\o033[01;32m\ examples\,\ 0\ failures \o033[0m/g' \\
      | ${REPLACER} --unbuffered 's/\ returns\ /\o033[01;32m\ returns\ /g' \\
      | ${REPLACER} --unbuffered 's/\ Do\ not\ use\ /\o033[48;5;235m\o033[38;5;196m\ Do\ not\ use\ /g' \\
      | ${REPLACER} --unbuffered 's/..Failure.Error:/\o033[48;5;235m\o033[38;5;196m..Failure.Error:/g' \\
      | ${REPLACER} --unbuffered 's/.FAILED\ /\o033[48;5;235m\o033[38;5;196m...FAILED\ \o033[0m/g' \\
      | ${REPLACER} --unbuffered 's/.failures:/\o033[48;5;235m\o033[38;5;196m.failures\o033[0m:/g' \\
      | ${REPLACER} --unbuffered 's/\ in\ tests\./\ in\ tests\.\o033[0m/g' \\
      | ${REPLACER} --unbuffered 's/expected\ the\ /\o033[0mexpected\ the\ /g' \\
      | ${REPLACER} --unbuffered 's/\[Command\ was\ successful\]/\o033[01;32m\[Command\ was\ successful\]/g' \\
      | ${REPLACER} --unbuffered 's/\ GET\ /\o033[01;35m\ GET\ /g' \\
      | ${REPLACER} --unbuffered 's/\ POST\ /\o033[01;35m\ POST\ /g' \\
      | ${REPLACER} --unbuffered 's/\ DELETE\ /\o033[01;35m\ DELETE\ /g' \\
      | ${REPLACER} --unbuffered 's/\ PUT\ /\o033[01;35m\ PUT\ /g' \\
      | ${REPLACER} --unbuffered 's/\ PATCH\ /\o033[01;35m\ PATCH\ /g' \\
      | ${REPLACER} --unbuffered 's/\ OPTIONS\ /\o033[01;35m\ OPTIONS\ /g' \\
      | ${REPLACER} --unbuffered 's/Top\ /\o033[38;5;100mTop\ /g' \\
      | ${REPLACER} --unbuffered 's/\ seconds\ /\o033[38;5;231m\ seconds\ /g' \\
      | ${REPLACER} --unbuffered 's/\ behaves\ like\ /\o033[01;36m\ behaves\ like\ /g' \\
      | ${REPLACER} --unbuffered 's/\ when\ /\o033[01;36m\ when\ /g' \\
      | ${REPLACER} --unbuffered 's/\ do\ /\o033[0m\ do\ /g' \\
      | ${REPLACER} --unbuffered 's/\ does\ /\o033[0m\ does\ /g' \\
      | ${REPLACER} --unbuffered 's/\ finds\ /\o033[0m\ finds\ /g' \\
      | ${REPLACER} --unbuffered 's/\ serializes\ /\o033[0m\ serializes\ /g' \\
      | ${REPLACER} --unbuffered 's/ErrorException:\ /\o033[38;5;196mErrorException:\ \o033[38;5;213m/g' \\
       | ${REPLACER} --unbuffered "s/\ require_once(.\/wp-content/\ require_once(\n$pwd_backslash_escaped_for_sed\/wp-content/g" \\
       | ${REPLACER} --unbuffered "s/\ require(.\/wp-content/\ require(\n$pwd_backslash_escaped_for_sed\/wp-content/g" \\
       | ${REPLACER} --unbuffered "s/\ require\ .\/wp-content/\ require\ \n$pwd_backslash_escaped_for_sed\/wp-content/g" \\
       | ${REPLACER} --unbuffered "s/\ include\ .\/wp-content/\ include\ \n$pwd_backslash_escaped_for_sed\/wp-content/g" \\
       | ${REPLACER} --unbuffered "s/\ include_once(.\/wp-content/\ include_once(\n$pwd_backslash_escaped_for_sed\/wp-content/g" \\
       | ${REPLACER} --unbuffered "s/\ in\ \//\ in\ \n\//g" \\
      | ${REPLACER} --unbuffered 's/Stack\ trace:/\o033[38;0mStack\ trace:/g' \\
      | ${REPLACER} --unbuffered 's/Call\ Stack:/\o033[38;0mCall\ Stack:/g' \\
      | ${REPLACER} --unbuffered 's/#. //g' \\
      | ${REPLACER} --unbuffered -E "/[Ee]rror[: ]/ s%\$pathpat%\$ccred&\$ccend%g" \\
      | ${REPLACER} --unbuffered -E "/[Ww]arning[: ]/ s%\$pathpat%\$ccyellow&\$ccend%g" \\
      | ${REPLACER} --unbuffered 's/\.\/spec\//\o033[0m\.\/spec\//g' \\
EOF
)
      # | ${REPLACER} --unbuffered 's/[^[:alpha:]#]\+/\o033[01;35m\ /g' \\

if [[ "${extension_to_observe-}" == "go"  ]] ; then
{
  # GO
	# ps aux | grep "${1-}" | head -1 |xargs
	prefix_to_run="[[ -n \\\"\$(ps aux | grep \\\"${1-}\\\" | grep -v 'grep'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps aux | grep \\\"${1-}\\\" | grep -v 'grep'  | head -1 | xargs | cut -d' ' -f2 )\\\" || go run \\\"$(pwd)/${*}\\\" && go run "
  file_to_watch="$(pwd)/"
  extension_to_observe="go"
}
elif [[ "${extension_to_observe-}" == "toml" ]] && [[ "${file_to_observe-}" == "Cargo.toml" ]] ; then
{
  # Rust TOML
  # cargo run --package progress --bin project_name

  # ps aux | grep "${1-}" | head -1 |xargs
  # nodemon --watch "$(pwd)/src" --ext rs  --exec "cargo run -q $(pwd)/Cargo.toml"
  # ps aux | grep "Cargo.toml" | grep -v 'grep' | grep -v 'nodemon'
  prefix_to_run="[[ -n \\\"\$(ps aux | grep '${file_to_observe-}' | grep -v 'grep' | grep -v 'nodemon'  | head -1 | xargs)\\\"  ]] && kill \\\"\$(ps aux | grep '${file_to_observe-}' | grep -v 'grep' | grep -v 'nodemon'  | head -1 | xargs | cut -d' ' -f2 )\\\" || cargo run -q \\\"$(pwd)/${file_to_observe-}\\\" && cargo run -q "
  file_to_watch="$(pwd)/src"
  extension_to_observe="rs"
}
elif [[ "${extension_to_observe-}" == "py"  ]] ; then
{
  # python
  # python  project_file
  # ps aux | grep "${1-}" | head -1 |xargs
   ps axt | grep live-server | grep coverage |xargs | cut -d\  -f1 |xargs  -I {} kill {}
  prefix_to_run="[[ -n \\\"\$(ps aux | grep '${file_to_observe-}' | grep -v 'grep'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps aux | grep '${file_to_observe-}' | grep -v 'grep'  | head -1 | xargs | cut -d' ' -f2 )\\\" || python \\\"$(pwd)/${file_to_observe-}\\\" && python "
  file_to_watch="$(pwd)/"
  extension_to_observe="py"
}
elif [[ "${extension_to_observe-}" == "rb"  ]] ; then
{
  # ruby
  extension_to_observe="rb"
  if ( grep -q "_spec.rb[[:space:]]*$" <<< "${file_to_observe-}" ) || ( grep -q '_spec.rb' <<<  "${file_to_observe-}" ) ; then  # if ends with or contains
  {
    # rspec yes ?
    # kill live-server coverage
    ps axt | grep live-server | grep coverage |xargs | cut -d\  -f1 |xargs  -I {} kill {}
    # one file
    local extra_args_to_run_preview=""
    if [[ -n "${observe_one_line}" ]] ; then # Criteria: if one numeric : then pass only one test to run but keep observing other files
    {
      extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"$(pwd)/${file_to_observe-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"$(pwd)/${observe_one_line-}\\\" && live-server coverage "
      extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
    }
    else
    {
      extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"$(pwd)/${file_to_observe-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"$(pwd)/${file_to_observe-}\\\" && live-server coverage "
      extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
    }
    fi
    local _files_to_rubocop="$(pwd)/${file_to_observe-}"
    local _files_to_rspec="$(pwd)/${file_to_observe-}"
    file_to_watch="$(pwd)/${file_to_observe-}"

    # try to find related classed from described yes ?
    local _maybe_control_list="${file_to_observe-}"
    local _maybe_name=""
    local _maybe_name2=""
    # echo "${file_to_observe-}"
    # cat "${file_to_observe-}" | grep  "^[[:space:]]*RSpec.describe"
    # grep  "^[[:space:]]*RSpec.describe"  < "${file_to_observe-}" | cuet "RSpec.describe"
    # grep  "^[[:space:]]*RSpec.describe"  < "${file_to_observe-}" | cuet "RSpec.describe" | xargs
                  grep  "^[[:space:]]*RSpec.describe"  < "${file_to_observe-}" | cuet "RSpec.describe" | xargs |  cut -d' ' -f1 |  cut -d, -f1
    _maybe_name=$(grep  "^[[:space:]]*RSpec.describe"  < "${file_to_observe-}" | cuet "RSpec.describe" | xargs |  cut -d' ' -f1 |  cut -d, -f1)  # assume tests use only this format
    echo "              _maybe_name:${_maybe_name-}"
                   grep  "^[[:space:]]*RSpec.describe"  < "${file_to_observe-}" | cuet "RSpec.describe" | xargs |  cut -d' ' -f1 |  cut -d, -f1 | sed 's/:/\n/g' | tail -1
    _maybe_name2=$(grep  "^[[:space:]]*RSpec.describe"  < "${file_to_observe-}" | cuet "RSpec.describe" | xargs |  cut -d' ' -f1 |  cut -d, -f1 | sed 's/:/\n/g' | tail -1)  # assume tests use only this format
    echo "             _maybe_name2:${_maybe_name2-}"

    if [[ -n "${_maybe_name}" ]] ; then
    {
      if ( ag -l "${_maybe_name}" | grep -v  '_spec.rb'  ) ; then # list all found filenames with ag with out other tests
      {
        local _possible_related_classes=""
        _rubocops="watch(%r{^${file_to_watch}\.rb\$})"
        _possible_related_classes="$( ag -l "${_maybe_name}" | grep -v  '_spec.rb' )"
echo "_possible_related_classes:${_possible_related_classes-}"
        if [[ -n "${_possible_related_classes}" ]] ; then
        {
          local one=""
          local _found=0
          while read -r one ; do
          {
            [[ -z "${one-}" ]] && continue # skip empty lines
            [[ -f "${one-}" ]] || continue # only if file exists

            _ignore_ruby_list "${one}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip ignored files

            _is_duplicated "${one}" "${_maybe_control_list}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip duplicated files

            file_to_watch="${file_to_watch}\"\\
 --watch \"$(pwd)/${one}"
            _files_to_rubocop="${_files_to_rubocop}\\\"\\
 \\\"$(pwd)/${one}"
            _rubocops="${_rubocops}
    watch(%r{^$(pwd)/${one}\$})"
            _maybe_control_list="${_maybe_control_list}
${one}"
            _found=$(( _found + 1 ))
          }
          done <<< "${_possible_related_classes}"
          # multiple files
          if [ ${_found} -gt 0 ] ; then
          {
            if [[ -n "${observe_one_line}" ]] ; then # Criteria: if one numeric : then pass only one test to run but keep observing other files
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"$(pwd)/${observe_one_line-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            else
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"${_files_to_rspec-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            fi
          }
          fi

          _found=0
          local __all_passed_files="$( sed 's/\.rb\ /.rb\n/g' <<< "${*-}")"
          echo __all_passed_files:"${__all_passed_files}"

          while read -r one ; do
          {
            [[ -z "${one-}" ]] && continue # skip empty lines
            [[ -f "${one-}" ]] || continue # only if file exists

            _ignore_ruby_list "${one}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip ignored files

            _is_duplicated "${one}" "${_maybe_control_list}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip duplicated files

            file_to_watch="${file_to_watch}\"\\
 --watch \"$(pwd)/${one}"
            _files_to_rubocop="${_files_to_rubocop}\\\"\\
 \\\"$(pwd)/${one}"
            _rubocops="${_rubocops}
    watch(%r{^$(pwd)/${one}\$})"

            if  ( grep -q "_spec.rb[[:space:]]*$"  <<< "${one}" ) ; then
            {
              _is_duplicated "${one}" "${_maybe_control_list}"
              _err=$?
              [ ${_err} -gt 0 ] && continue # skip duplicated files

              _maybe_control_list="${_maybe_control_list}
${one}"
              _files_to_rspec="${_files_to_rspec}\\\"\\
 \\\"$(pwd)/${one}"
            }
            else
            {
              _maybe_control_list="${_maybe_control_list}
${one}"
            }
            fi

            _found=$(( _found + 1 ))
          }
          done <<< "${__all_passed_files}"
          # multiple files
          echo _files_to_rspec:"${_files_to_rspec}"
          ## DEBUG exit 0
          if [ ${_found} -gt 0 ] ; then
          {
            if [[ -n "${observe_one_line}" ]] ; then # Criteria: if one numeric : then pass only one test to run but keep observing other files
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"$(pwd)/${observe_one_line-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            else
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"${_files_to_rspec-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            fi
          }
          fi

  replacer_colors_sufix2=$(cat <<-EOF
      | ${REPLACER} --unbuffered 's/"${_maybe_name-}"/\o033[38;5;178m"${_maybe_name-}"\o033[0m/g' \\
      | ${REPLACER} --unbuffered 's/"${_maybe_name-}"/\o033[38;5;178m"${_maybe_name-}"\o033[0m/g' \\

EOF
)
   # | ${REPLACER} --unbuffered 's@/./@/@g' \\

        } # end [[ -n "${_possible_related_classes}" ]]
        fi
      } # end ag -l "${_maybe_name}" | grep -v  '_spec.rb'
      fi
    } # end [[ -n "${_maybe_name}" ]]
    fi

    if [[ -n "${_maybe_name2}" ]] ; then
    {
      if ( ag -l "${_maybe_name2}" | grep -v  '_spec.rb'  ) ; then # list all found filenames with ag with out other tests
      {
        local _possible_related_classes=""
        # _rubocops="watch(%r{^${file_to_watch}\.rb\$})"
        _possible_related_classes="$( ag -l "${_maybe_name2}" | grep -v  '_spec.rb' )"
echo "_possible_related_classes:${_possible_related_classes-}"
        if [[ -n "${_possible_related_classes}" ]] ; then
        {
          local one=""
          local _found=0
          while read -r one ; do
          {
            [[ -z "${one-}" ]] && continue # skip empty lines
            [[ -f "${one-}" ]] || continue # only if file exists

            _ignore_ruby_list "${one}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip ignored files

            _is_duplicated "${one}" "${_maybe_control_list}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip duplicated files

            file_to_watch="${file_to_watch}\"\\
 --watch \"$(pwd)/${one}"
            _files_to_rubocop="${_files_to_rubocop}\\\"\\
 \\\"$(pwd)/${one}"
            _rubocops="${_rubocops}
    watch(%r{^$(pwd)/${one}\$})"
            _maybe_control_list="${_maybe_control_list}
${one}"
            _found=$(( _found + 1 ))
          }
          done <<< "${_possible_related_classes}"
          # multiple files
          if [ ${_found} -gt 0 ] ; then
          {
            if [[ -n "${observe_one_line}" ]] ; then # Criteria: if one numeric : then pass only one test to run but keep observing other files
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"$(pwd)/${observe_one_line-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            else
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"${_files_to_rspec-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            fi
          }
          fi

          _found=0
          local __all_passed_files="$( sed 's/\.rb\ /.rb\n/g' <<< "${*-}")"
          echo __all_passed_files:"${__all_passed_files}"

          while read -r one ; do
          {
            [[ -z "${one-}" ]] && continue # skip empty lines
            [[ -f "${one-}" ]] || continue # only if file exists

            _ignore_ruby_list "${one}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip ignored files

            _is_duplicated "${one}" "${_maybe_control_list}"
            _err=$?
            [ ${_err} -gt 0 ] && continue # skip duplicated files

            file_to_watch="${file_to_watch}\"\\
 --watch \"$(pwd)/${one}"
            _files_to_rubocop="${_files_to_rubocop}\\\"\\
 \\\"$(pwd)/${one}"
            _rubocops="${_rubocops}
    watch(%r{^$(pwd)/${one}\$})"

            if  ( grep -q "_spec.rb[[:space:]]*$"  <<< "${one}" ) ; then
            {
              _is_duplicated "${one}" "${_maybe_control_list}"
              _err=$?
              [ ${_err} -gt 0 ] && continue # skip duplicated files

              _maybe_control_list="${_maybe_control_list}
${one}"
              _files_to_rspec="${_files_to_rspec}\\\"\\
 \\\"$(pwd)/${one}"
            }
            else
            {
              _maybe_control_list="${_maybe_control_list}
${one}"
            }
            fi

            _found=$(( _found + 1 ))
          }
          done <<< "${__all_passed_files}"
          # multiple files
          echo _files_to_rspec:"${_files_to_rspec}"
          # DEBUG exit 0
          if [ ${_found} -gt 0 ] ; then
          {
            if [[ -n "${observe_one_line}" ]] ; then # Criteria: if one numeric : then pass only one test to run but keep observing other files
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"$(pwd)/${observe_one_line-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            else
            {
              extra_args_to_run_preview="clear && bundle exec rubocop -A  \\\"${_files_to_rubocop-}\\\" && FULL_SPEC_RUN=true RACK_ENV=test RAILS_ENV=test NODE_ENV=test COVERAGE=true CI_RSPEC=false  bundle exec rspec --tty --color --format documentation \\\"${_files_to_rspec-}\\\" && live-server coverage "
              extra_args_to_run="[[ -n \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps axt | grep 'live-server' | grep 'coverage'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ( ${extra_args_to_run_preview}  ) && ( ${extra_args_to_run_preview}  ) "
            }
            fi
          }
          fi

  replacer_colors_sufix3=$(cat <<-EOF
      | ${REPLACER} --unbuffered 's/"${_maybe_name2-}"/\o033[38;5;178m"${_maybe_name2-}"\o033[0m/g' \\
      | ${REPLACER} --unbuffered 's/"${_maybe_name2-}"/\o033[38;5;178m"${_maybe_name2-}"\o033[0m/g' \\

EOF
)

   # | ${REPLACER} --unbuffered 's@/./@/@g' \\

        } # end [[ -n "${_possible_related_classes}" ]]
        fi
      } # end ag -l "${_maybe_name}" | grep -v  '_spec.rb'
      fi
    } # end [[ -n "${_maybe_name}" ]]
    fi
    file_to_observe=""

  }
  else
  {
    # rspec no ?
    prefix_to_run="[[ -n \\\"\$(ps aux | grep '${file_to_observe-}' | grep -v 'grep'  | head -1 | xargs)\\\"  ]] || kill \\\"\$(ps aux | grep '${file_to_observe-}' | grep -v 'grep'  | head -1 | xargs | cut -d' ' -f2 )\\\" || ruby \\\"$(pwd)/${file_to_observe-}\\\" && ruby "
    file_to_watch="$(pwd)/${file_to_observe-}"
    file_to_observe="$(pwd)/${file_to_observe-}"
  }
  fi


  #
}
else
{
  extension_to_observe="rs,py,go,bash,sh,kv,php,rb"
}
fi
echo "     extension_to_observe:${extension_to_observe-}"
echo "                _filename:${_filename-}"
echo "             _script_name:${_script_name-}"
echo "            prefix_to_run:${prefix_to_run-}"
echo "          file_to_observe:${file_to_observe-}"
echo "            file_to_watch:${file_to_watch-}"
echo "        extra_args_to_run:${extra_args_to_run-}"


if [[ $REPLACERGNU == "YES" ]] ; then
{
  echo '-----'
  if [[ -n "${extra_args_to_run}" ]] ; then
  {
#     if ( bundle info guard   >/dev/null 2>&1  ) ; then
#     {

#       cat <<-EOF > ".${_filename}.watch.test.guardfile"
# group :red_green_refactor do
#   guard :rubocop, all_on_start: false, cli: ['-A'] do
#      # watch(%r{^request_spec\.rb$})
#     ${_rubocops}
#   end

#   guard :rspec, cmd: "bundle exec rspec --tty --color --format documentation" do
#     # watch(%r{^request_spec\.rb$})
#     ${_rpec_file}
#   end
# end

# EOF
#       cat <<-EOF > ".${_filename}.watch.test.bash"
# #!/usr/bin/env bash

# echo "bundle install guard guard-rubocop guard-rspec"

# bundle add guard >/dev/null 2>&1;
# bundle add guard-rubocop >/dev/null 2>&1;
# bundle add guard-rspec >/dev/null 2>&1;

# echo "bundle guard -G \"$(pwd)/.${_filename}.watch.test.guardfile\" "

# bundle exec guard -G "$(pwd)/.${_filename}.watch.test.guardfile" \

#       # bundle remove guard-rubocop  >/dev/null 2>&1;
#       git checkout Gemfile Gemfile.lock

# EOF
#       # | ${REPLACER} --unbuffered 's@/./@/@g' \
#       chmod a+x  ".${_filename}.watch.test.bash"
#       ./".${_filename}.watch.test.bash"

#     }


#     }
#     elif ( command -v watchman >/dev/null 2>&1; )  ; then
#     {
#       file_to_watch="$( ${REPLACER} 's/\-\-watch//g'  <<< "${file_to_watch}" )"
#       # ruby rspec observe spec/concern_spec.rb
#       echo " \"${extra_args_to_run} ${file_to_observe}\"  "

#       # watchman watch "${file_to_observe}"  trigger "${extra_args_to_run} ${file_to_observe}" 2>&1  \
#       cat <<-EOF > ".${_filename}.watchman.watch.test.bash"
# ${replacer_colors_prefix}

# ${extra_args_to_run} 2>&1  \

# watchman trigger-del "$pwd_backslash_escaped_for_sed" "${_maybe_name-}"
# ${replacer_colors_sufix}
# EOF
#       watchman watch \"${file_to_watch-}\"
#       watchman -- trigger "$pwd_backslash_escaped_for_sed" "${_maybe_name-}" '*.rb' -- "$cwd/.${_filename}.watchman.watch.test.bash"

#       # | ${REPLACER} --unbuffered 's@/./@/@g' \
#       chmod a+x  ".${_filename}.watchman.watch.test.bash"
#       ./".${_filename}.watchman.watch.test.bash"

    # }
    if ( command -v nodemon >/dev/null 2>&1; )  ; then
    {
      # ruby rspec observe spec/concern_spec.rb
      echo "nodemon --watch \"${file_to_watch-}\" --ext ${extension_to_observe} --spawn --exec \"${extra_args_to_run} ${file_to_observe}\"  "

      [[ -e ./".${_filename}.nodemon.watch.test.bash" ]] && rm -rf ./".${_filename}.nodemon.watch.test.bash"

      # nodemon --watch "${file_to_observe}" --ext ${extension_to_observe} --spawn --exec "${extra_args_to_run} ${file_to_observe}" 2>&1  \

cat <<-EOF >  ".${_filename}.nodemon.watch.test.bash"
${replacer_colors_prefix}

nodemon --watch "${file_to_watch}" \\
--ext ${extension_to_observe} \\
--spawn \\
--exec "${extra_args_to_run} ${file_to_observe}"  2>&1  \\
${replacer_colors_sufix}
${replacer_colors_sufix2}
${replacer_colors_sufix3}


EOF
# ${replacer_colors_sufix}
# ${replacer_colors_sufix2}
      # | ${REPLACER} --unbuffered 's@/./@/@g' \
      chmod a+x  ".${_filename}.nodemon.watch.test.bash"
      ./".${_filename}.nodemon.watch.test.bash"
    }
    elif ( command -v watchexec >/dev/null 2>&1; )  ; then
    {
      # ruby rspec observe spec/concern_spec.rb
      echo "watchexec --watch \"${file_to_watch-}\" --exts ${extension_to_observe} --restart \"${extra_args_to_run} ${file_to_observe}\"  "
      [[ -e ./".${_filename}.watchexec.watch.test.bash" ]] && rm -rf ./".${_filename}.watchexec.watch.test.bash"

      # watchexec --watch "${file_to_observe}" --exts ${extension_to_observe} --restart "${extra_args_to_run} ${file_to_observe}" 2>&1  \
      cat <<-EOF > ".${_filename}.watchexec.watch.test.bash"
${replacer_colors_prefix}

watchexec --watch "${file_to_watch}" --exts ${extension_to_observe} --restart "${extra_args_to_run} ${file_to_observe}" 2>&1  \
${replacer_colors_sufix}
${replacer_colors_sufix2}
EOF
      # | ${REPLACER} --unbuffered 's@/./@/@g' \\
      chmod a+x  ".${_filename}.watchexec.watch.test.bash"
      ./".${_filename}.watchexec.watch.test.bash"
    }
    else
    {
      echo "ERROR could not find watchexec or nodemon to start
      Please install either:

        faster   https://github.com/watchexec/watchexec
        descent  https://facebook.github.io/watchman/
        classic  https://www.npmjs.com/package/nodemon

      "
      exit 1
    }
    fi
  }
  #          ------------
  #          ------------
  #          ------------
  #          ------------
  #          ------------
  #          ------------
  else          #  prefix style
  #         -------------
  #         -------------
  #         -------------
  #         -------------
  #         -------------
  #         -------------
  #         -------------
  {
#     if ( bundle info guard   >/dev/null 2>&1  ) ; then
#     {
#       cat <<-EOF > ".${_filename}.watch.test.guardfile"
# group :red_green_refactor do
#   guard :rubocop, all_on_start: false, cli: ['-A'] do
#      # watch(%r{^request_spec\.rb$})
#     ${_rubocops}
#   end

#   guard :rspec, cmd: "bundle exec rspec --tty --color --format documentation" do
#     # watch(%r{^request_spec\.rb$})
#     ${_rpec_file}
#   end
# end

# EOF
#       cat <<-EOF > ".${_filename}.guard.watch.test.bash"
# #!/usr/bin/env bash

# echo "bundle install guard guard-rubocop guard-rspec"

# bundle add guard >/dev/null 2>&1;
# bundle add guard-rubocop >/dev/null 2>&1;
# bundle add guard-rspec >/dev/null 2>&1;

# echo "bundle guard -G \"$(pwd)/.${_filename}.watch.test.guardfile\" "

# bundle exec guard -G "$(pwd)/.${_filename}.watch.test.guardfile" \

#       # bundle remove guard-rubocop  >/dev/null 2>&1;
#       git checkout Gemfile Gemfile.lock

# EOF
#       # | ${REPLACER} --unbuffered 's@/./@/@g' \
#       chmod a+x  ".${_filename}.guard.watch.test.bash"
#       ./".${_filename}.guard.watch.test.bash"

#     }
    if ( command -v watchexec >/dev/null 2>&1; )  ; then
    {
      # go observe homework.go
      # rust observe Cargo.toml
      # echo "nodemon --watch \"${file_to_watch-}\"  --exts ${extension_to_observe} --restart \"${prefix_to_run-}$(pwd)/${*}\"  "
      echo "watchexec --watch \"./\" --exts py,go,bash,sh,kv,php,rb --restart \"${prefix_to_run-}$(pwd)/${*}\" "
      [[ -e ./".${_filename}.watchexec.watch.test.bash" ]] && rm -rf ./".${_filename}.watchexec.watch.test.bash"

      # watchexec --watch "${file_to_observe}" --exts ${extension_to_observe} --restart "${extra_args_to_run} ${file_to_observe}" 2>&1  \
      cat <<-EOF > ".${_filename}.watchexec.watch.test.bash"
${replacer_colors_prefix}

watchexec --watch "./" --exts py,go,bash,sh,kv,php,rb --restart "${prefix_to_run-}$(pwd)/${*}"  2>&1  \
${replacer_colors_sufix}
EOF
      chmod a+x  ".${_filename}.watchexec.watch.test.bash"
      ./".${_filename}.watchexec.watch.test.bash"
#     }
#     elif ( command -v watchman >/dev/null 2>&1; )  ; then
#     {
#       file_to_watch="$( ${REPLACER} 's/\-\-watch//g'  <<< "${file_to_watch}" )"
#       # ruby rspec observe spec/concern_spec.rb
#       echo "watchman watch \"${file_to_watch-}\"  trigger \"${extra_args_to_run} ${file_to_observe}\"  "

#       # watchman watch "${file_to_observe}"  trigger "${extra_args_to_run} ${file_to_observe}" 2>&1  \
#       cat <<-EOF > ".${_filename}.watchman.watch.test.bash"
# #!/usr/bin/env bash

# pathpat="(/[^/]*)+:[0-9]+"
# ccred=\$(echo -e "\033[0;31m")
# ccyellow=\$(echo -e "\033[0;33m")
# ccend=\$(echo -e "\033[0m")
# # sed -E
# # -e "/[Ee]rror[: ]/ s%$pathpat%$ccred&$ccend%g"
# # -e "/[Ww]arning[: ]/ s%$pathpat%$ccyellow&$ccend%g"

# "${prefix_to_run-}$(pwd)/${*}"  2>&1  \

# watchman trigger-del "$cwd" "${_maybe_name-}"
# ${replacer_colors_sufix}
# EOF
#       watchman watch \"${file_to_watch-}\"
#       watchman -- trigger "$cwd" "${_maybe_name-}" '*.rb' -- "$cwd/.${_filename}.watchman.watch.test.bash"

#       # | ${REPLACER} --unbuffered 's@/./@/@g' \
#       chmod a+x  ".${_filename}.watchman.watch.test.bash"
#       ./".${_filename}.watchman.watch.test.bash"

    }
    elif ( command -v nodemon >/dev/null 2>&1; )  ; then
    {
      # go observe homework.go
      # rust observe Cargo.toml
      # echo "nodemon --watch \"${file_to_watch-}\"  --ext ${extension_to_observe} --exec \"${prefix_to_run-}$(pwd)/${*}\"  "
      echo "nodemon --watch \"./\" --ext py,go,bash,sh,kv,php,rb --spawn --exec \"${prefix_to_run-}$(pwd)/${*}\" "
      [[ -e ./".${_filename}.nodemon.watch.test.bash" ]] && rm -rf ./".${_filename}.nodemon.watch.test.bash"

      # nodemon --watch "${file_to_observe}" --ext ${extension_to_observe} --spawn --exec "${extra_args_to_run} ${file_to_observe}" 2>&1  \
      cat <<-EOF > ".${_filename}.nodemon.watch.test.bash"
${replacer_colors_prefix}

nodemon --watch "./" --ext py,go,bash,sh,kv,php,rb --spawn --exec "${prefix_to_run-}$(pwd)/${*}"  2>&1  \
${replacer_colors_sufix}

EOF
      chmod a+x  ".${_filename}.nodemon.watch.test.bash"
      ./".${_filename}.nodemon.watch.test.bash"
    }
    else
    {
      echo "ERROR could not find watchexec or nodemon to start
      Please install either:

        faster   https://github.com/watchexec/watchexec
        descent  https://facebook.github.io/watchman/
        classic  https://www.npmjs.com/package/nodemon

      "
      exit 1
    }
    fi

  }
  fi
  echo '-----'

}
else
{
  echo "Error I do not know how to use sed for mac "
}
fi


} # end _main


_main "${1:-}" "${2:-}" "${*-}"
