#!/usr/bin/env bash
#!/bin/bash
#
# @author Zeus Intuivo <zeus@intuivo.com>
#
THISSCRIPTNAME=`basename "$0"`

if [[ -z "$1"  ]] || [[ -z "$2"  ]] ; then   # empty value
  echo "

From one folder to another  using batch in subfolders, you don't gets stoped while the computer 'builds' a list
using rsync which is suppoused to be faster at the time I did this (2017)


${THISSCRIPTNAME}   from_path   to_path
  "
    exit 0
fi

if command -v wget >/dev/null 2>&1; then
    echo '1'
else
    echo "wget not found. please install"
    exit 69
fi

if command -v rsync >/dev/null 2>&1; then
    echo '2'
else
    echo "rsync not found. please install"
    exit 69
fi


if command -v find >/dev/null 2>&1; then
    echo '3'
else
    echo "find not found. please install"
    exit 69
fi


if command -v sed >/dev/null 2>&1; then
    echo '4'
else
    echo "sed not found. please install"
    exit 69
fi

THISSCRIPTNAME=`basename "$0"`
load_execute_command_wget(){
    local provider="/_/clis/execute_command_intuivo_cli/execute_command"
    [   -e "${provider}"  ] && source "${provider}"
    [ ! -e "${provider}"  ] && eval """$(wget --quiet --no-check-certificate  https://raw.githubusercontent.com/zeusintuivo/execute_command_intuivo_cli/master/execute_command -O -  2>/dev/null )"""   # suppress only wget download messages, but keep wget output for variable
    ( ( ! command -v type passed >/dev/null 2>&1; ) && echo -e "\n \n  ERROR! Loading execute_command \n \n " && exit 69; )
} # end load_execute_command_wget
load_execute_command_wget



if command -v anounce >/dev/null 2>&1; then
    echo '5'
else
    echo "anounce not found. Check Your internet connection"
    exit 69
fi

function remove_last_slash {
    sed 's/\/$//g'  # remove last slash
}


function slashes_to_newlines {
    sed -e 's/'"\/"'/'"\n"'/g' #splits slashed into enters with newlines divides slashes
}
# TEST: echo "/_/work/savedo/projects/savedo-cms-wagon-de/app/assets/fonts/bootstrap/" | slashes_to_newlines
# EXPECTATION:
# _
# work
# savedo
# projects
# savedo-cms-wagon-de
# app
# assets
# fonts
# bootstrap
#
function remove_double_slashes { #removes double slashes in path and converts ./ to PWD
    # usage
    #        1. FOLDER=$(remove_double_slashes ".//_/work/savedo/projects/savedo-cms-wagon-de///app/assets///fonts/bootstrap///")
    #        2. remove_double_slashes ".//_/work/savedo/projects/savedo-cms-wagon-de///app/assets///fonts/bootstrap///"
    local incoming_string="${@}"
    local PARTS=$(slashes_to_newlines <<< "${incoming_string}")
    local ONE_PART
    local result=""
    local COUNTER=0
    local using_string=""
    while read -r ONE_PART; do
    # for ONE_PART in ${PARTS}; do
    {
        if [ ! -z "${ONE_PART}" ] ; then # if not empty
        {
            using_string="${ONE_PART}"
            if [ $COUNTER -eq 0 ] && ( [ "${using_string}" == "." ] || [ -d "${using_string}" ] ) ; then
            {
                result="$(pwd)"
                [ -d "${using_string}" ] && result="$(pwd)/${using_string}"
            } else {
                if [ $COUNTER -eq 0 ] ; then
                {
                    result="${using_string}"
                    [ -d "${using_string}" ] && [[ ${incoming_string:0:1} != "/" ]] && result="$(pwd)/${using_string}"
                } else {
                    result="${result}/${using_string}"
                }
                fi

            }
            fi
            (( COUNTER++ ))
        }
        fi
    }
    done <<< "${PARTS}"
    if [[ ${incoming_string:0:1} == "/" ]] ; then # get first char from string
    {
       [[ ${result:0:1} != "/" ]] && result="/${result}"
    }
    fi
    echo "${result}"
    return 0
}
# TEST: remove_double_slashes "/_/work/savedo/projects/savedo-cms-wagon-de///app/assets///fonts/bootstrap///"
# EXPECTATION: /_/work/savedo/projects/savedo-cms-wagon-de/app/assets/fonts/bootstrap

# TEST: remove_double_slashes "./work/savedo/projects/savedo-cms-wagon-de///app/assets///fonts/bootstrap///"
# EXPECTATION: ${PWD}/work/savedo/projects/savedo-cms-wagon-de/app/assets/fonts/bootstrap


function copy_using_rsync() {
    local FROMPATH="${1}"
    local TOPATH="${2}"
    local filename just_file_name COPY_FROM one_item all_files COPY_FROM_corrected TOPATH_corrected
    anounce Copy Batch

    all_files=$(find "$FROMPATH" -maxdepth 1 | sed s"$FROMPATH"/g | sed 's/\.\///g' | sed '/^\.$/d' )
    #anounce  Found:"${all_files}"
    #exit
    while read -r one_item; do
    {
        if [ ! -z "${one_item}" ] && [[ "${FROMPATH}/${one_item}" != "${FROMPATH}/${FROMPATH}" ]]; then
        {
            filename=$(escape_filename <<< "${one_item}")
            [ -d "${FROMPATH}/${filename}/" ] && mkdir -p "${TOPATH}/${filename}"
            anounce "${filename}"
            just_file_name=$(echo $(basename "${filename}"))
            if [ -e "${filename}" ] && [ ! -e "${FROMPATH}/${filename}" ]; then
            {
                COPY_FROM="${filename}"
            }
            elif [ ! -e "${filename}" ] && [ -e "${FROMPATH}/${filename}" ]; then
            {
                COPY_FROM="${FROMPATH}/${filename}"
            }
            fi
            COPY_FROM_corrected=$(remove_double_slashes "${COPY_FROM}")
            # DEBUG echo "${COPY_FROM}"
            # DEBUG echo "${COPY_FROM_corrected}"
            TOPATH_corrected=$(remove_double_slashes "${TOPATH}")
            # DEBUG echo "${TOPATH}"
            # DEBUG echo "${TOPATH_corrected}"
            anounce_command rsync -av "${COPY_FROM_corrected}" "${TOPATH_corrected}/"
        }
        fi
    }
    done <<< "${all_files}"
}


copy_using_rsync "${1}" "${2}"

